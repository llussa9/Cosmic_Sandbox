<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Á†ÇÊôÇË®à„Åø„Åè„Åò | Another Moon</title>
  <style>
    :root {
      --bg-color: #05030f;
      --palette-1: #8bd5ff;
      --palette-2: #ff9df0;
      --palette-3: #ff4e8d;
      --palette-4: #c048ff;
      --palette-5: #ff6ad5;
      --palette-6: #ff796f;
      --palette-7: #ffeb8a;
      --palette-8: #2cf5c5;
      --hg-x: 50%;
      --hg-y: 50%;
      --hg-scale: 1;
      --grain-size: 1;
      --magic-fill: 0;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; }

    body {
      background: var(--bg-color);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fdfbff;
      overflow: hidden;
      transition: background 1s ease;
    }

    #fx {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 0;
    }

    .scene {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      transition: opacity 0.8s ease;
      pointer-events: auto;
    }
    .scene.hide {
      opacity: 0;
    }

    .hourglass-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
      padding: 24px;
      max-width: 900px;
      pointer-events: none;
    }

    .hourglass {
      position: fixed;
      left: var(--hg-x);
      top: var(--hg-y);
      transform: translate(-50%, -50%) scale(var(--hg-scale));
      width: 260px;
      height: 380px;
      max-width: 55vw;
      max-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      transition: opacity 0.8s ease;
    }

    /* ‰∏ä‰∏ã„ÅÆ„Éó„É¨„Éº„ÉàÔºàÂè∞Â∫ßÔºâ */
    .plate {
      position: absolute;
      left: 22%;
      right: 22%;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg,
        rgba(255,255,255,0.4),
        rgba(180,180,255,0.4),
        rgba(255,255,255,0.4)
      );
      box-shadow:
        0 4px 12px rgba(0,0,0,0.6),
        0 0 18px rgba(255,255,255,0.35);
      opacity: 0.9;
    }
    .plate-top { top: 7%; }
    .plate-bottom { bottom: 7%; }

    /* „Ç∑„É≥„Éó„É´„Å™‰∏ä‰∏ã‰∫å„Å§‰∏âËßíÂΩ¢„ÅÆ„Ç¨„É©„Çπ */
    .glass {
      position: absolute;
      inset-inline: 32%;
      top: 12%;
      bottom: 12%;
      clip-path: polygon(
        0% 0%,
        100% 0%,
        50% 46%,
        50% 54%,
        100% 100%,
        0% 100%,
        50% 54%,
        50% 46%
      );
      background:
        radial-gradient(circle at 20% 15%, rgba(255,255,255,0.35) 0, transparent 35%),
        radial-gradient(circle at 80% 85%, rgba(255,255,255,0.18) 0, transparent 45%),
        linear-gradient(135deg, rgba(255,255,255,0.16), rgba(0,0,0,0.35));
      box-shadow:
        0 0 26px rgba(255, 255, 255, 0.3),
        0 0 64px rgba(255, 255, 255, 0.16);
      opacity: 0.85;
      transition: opacity 0.6s ease;
    }

    .hourglass-outline {
      position: absolute;
      inset-inline: 32%;
      top: 12%;
      bottom: 12%;
      clip-path: polygon(
        0% 0%,
        100% 0%,
        50% 46%,
        50% 54%,
        100% 100%,
        0% 100%,
        50% 54%,
        50% 46%
      );
      border: 1px solid rgba(255,255,255,0.3);
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      backdrop-filter: blur(2px);
      transform-origin: center center;
      transition: opacity 0.8s ease, box-shadow 1s ease;
    }

    .hourglass-outline.glow-strong {
      box-shadow:
        0 0 40px rgba(255,255,255,0.9),
        0 0 120px rgba(255,230,255,0.9),
        0 0 220px rgba(255,250,255,0.9);
      animation: pulseGlow 2.6s ease-in-out infinite alternate;
    }

    @keyframes pulseGlow {
      0%   { box-shadow: 0 0 30px rgba(255,255,255,0.7), 0 0 120px rgba(255,230,255,0.7); }
      100% { box-shadow: 0 0 60px rgba(255,255,255,1), 0 0 220px rgba(255,250,255,1); }
    }

    .sand-top,
    .sand-bottom {
      position: absolute;
      inset-inline: 36%;
      background-size: 160% 160%;
      background-position: center;
      transform-origin: center top;
      overflow: hidden;
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.6));
      mix-blend-mode: screen;
      opacity: 1;
      transition: opacity 0.5s ease;
    }

    .sand-top {
      top: 17%;
      height: 32%;
      clip-path: polygon(0% 0%, 100% 0%, 50% 100%);
    }

    .sand-bottom {
      bottom: 17%;
      height: 32%;
      clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
      transform-origin: center bottom;
      opacity: 0;
    }

    .sand-top::before,
    .sand-bottom::before {
      content: "";
      position: absolute;
      inset: -12%;
      background-image:
        radial-gradient( calc(2px * var(--grain-size)) calc(2px * var(--grain-size)) at 10% 20%, rgba(255,255,255,0.9) 0, transparent 60%),
        radial-gradient( calc(1.5px * var(--grain-size)) calc(1.5px * var(--grain-size)) at 60% 40%, rgba(255,255,255,0.7) 0, transparent 60%),
        radial-gradient( calc(2px * var(--grain-size)) calc(2px * var(--grain-size)) at 20% 80%, rgba(255,255,255,0.85) 0, transparent 60%),
        radial-gradient( calc(2px * var(--grain-size)) calc(2px * var(--grain-size)) at 80% 70%, rgba(255,255,255,0.7) 0, transparent 60%);
      opacity: 0.9;
      mix-blend-mode: screen;
    }

    .sand-top.run  { animation: topDrain 30s linear forwards; }
    .sand-bottom.run { animation: bottomFill 30s linear forwards; }

    .sand-stream {
      position: absolute;
      top: 36%;
      bottom: 36%;
      left: 50%;
      width: 6px;
      transform: translateX(-50%);
      background-image: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0) 0%,
        #ffe0ff 10%,
        #ff9df0 30%,
        #ff4e8d 55%,
        #c048ff 80%,
        rgba(255, 255, 255, 0) 100%
      );
      filter:
        blur(0.3px)
        drop-shadow(0 0 6px rgba(255, 255, 255, 0.85));
      opacity: 1;
      transition: opacity 0.5s ease;
    }

    .sand-stream.run {
      animation: streamPulse 0.8s linear infinite,
                 streamFade 30s linear forwards;
    }

    .sand-particles {
      position: absolute;
      top: 46%;
      left: 50%;
      width: 70px;
      height: 90px;
      transform: translateX(-50%);
      pointer-events: none;
      overflow: visible;
      opacity: 1;
      transition: opacity 0.5s ease;
    }

    .sand-particles span {
      position: absolute;
      width: calc(2px * var(--grain-size));
      height: calc(4px * var(--grain-size));
      border-radius: 999px;
      background: radial-gradient(circle, #ffffff 0, #ffe0ff 40%, transparent 100%);
      opacity: 0.7;
      animation: fall 1.2s linear infinite;
    }

    .sand-particles span:nth-child(1) { left: 35%; animation-delay: 0s; }
    .sand-particles span:nth-child(2) { left: 52%; animation-delay: -0.3s; }
    .sand-particles span:nth-child(3) { left: 45%; animation-delay: -0.6s; }
    .sand-particles span:nth-child(4) { left: 40%; animation-delay: -0.9s; }

    .sand-floor {
      position: absolute;
      left: 26%;
      right: 26%;
      bottom: 17%;
      height: 9%;
      border-radius: 999px;
      box-shadow:
        0 -4px 14px rgba(255, 255, 255, 0.4),
        0 0 24px rgba(255, 0, 120, 0.4);
      opacity: 0;
      transform-origin: center;
      transform: scaleY(0.7);
      transition: opacity 1s ease, transform 1s ease;
    }

    .sand-floor.drain {
      animation: sandFloorDrain 2.4s linear forwards;
    }

    .crack-layer {
      position: absolute;
      inset-inline: 32%;
      top: 12%;
      bottom: 12%;
      pointer-events: none;
      clip-path: polygon(
        0% 0%,
        100% 0%,
        50% 46%,
        50% 54%,
        100% 100%,
        0% 100%,
        50% 54%,
        50% 46%
      );
      opacity: 0;
      transition: opacity 0.4s ease, filter 0.4s ease;
      mix-blend-mode: screen;
    }

    .crack-layer.step1 {
      opacity: 0.35;
      background-image:
        repeating-linear-gradient(128deg,
          rgba(255,255,255,0.6) 0,
          rgba(255,255,255,0.6) 1px,
          transparent 1px,
          transparent 7px),
        repeating-linear-gradient(-152deg,
          rgba(255,255,255,0.35) 0,
          rgba(255,255,255,0.35) 1px,
          transparent 1px,
          transparent 9px);
      background-size: 90px 80px, 80px 80px;
    }

    .crack-layer.step2 {
      opacity: 0.55;
      background-image:
        repeating-linear-gradient(135deg,
          rgba(255,255,255,0.7) 0,
          rgba(255,255,255,0.7) 1.2px,
          transparent 1.2px,
          transparent 6px),
        repeating-linear-gradient(-140deg,
          rgba(255,255,255,0.45) 0,
          rgba(255,255,255,0.45) 1px,
          transparent 1px,
          transparent 7px),
        repeating-linear-gradient(160deg,
          rgba(255,255,255,0.25) 0,
          rgba(255,255,255,0.25) 1px,
          transparent 1px,
          transparent 10px);
      background-size: 70px 70px, 60px 60px, 110px 110px;
    }

    .crack-layer.step3 {
      opacity: 0.85;
      background-image:
        repeating-linear-gradient(135deg,
          rgba(255,255,255,0.9) 0,
          rgba(255,255,255,0.9) 1.4px,
          transparent 1.4px,
          transparent 5px),
        repeating-linear-gradient(-145deg,
          rgba(255,255,255,0.7) 0,
          rgba(255,255,255,0.7) 1.2px,
          transparent 1.2px,
          transparent 6px),
        repeating-linear-gradient(162deg,
          rgba(255,255,255,0.45) 0,
          rgba(255,255,255,0.45) 1px,
          transparent 1px,
          transparent 9px);
      background-size: 54px 54px, 50px 50px, 90px 90px;
      box-shadow: 0 0 22px rgba(255,255,255,0.9);
    }

    .crack-layer.hot {
      filter: hue-rotate(-40deg) saturate(2.2) brightness(1.3);
    }

    .hourglass-outline.shake {
      animation: shakeGlass 0.4s ease-in-out 1;
    }

    @keyframes shakeGlass {
      0% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.01) rotate(1.1deg); }
      50% { transform: scale(1.01) rotate(-1.1deg); }
      75% { transform: scale(1.005) rotate(0.5deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    .hourglass-outline.shatter {
      animation: shatterOut 1.2s ease forwards;
    }

    .sand-fall {
      position: fixed;
      width: 4px;
      height: 0;
      border-radius: 999px;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.6));
      pointer-events: none;
      z-index: 1;
      opacity: 0;
      overflow: hidden;
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }

    .sand-fall.animate {
      animation: sandFallDown 3.6s ease-in forwards;
    }

    @keyframes sandFallDown {
      0%   { height: 0; opacity: 1; transform: translateY(0); }
      40%  { height: 100vh; opacity: 1; transform: translateY(0); }
      100% { height: 100vh; opacity: 0; transform: translateY(5vh); }
    }

    @keyframes fall {
      0%   { transform: translateY(-30px); opacity: 0; }
      20%  { opacity: 0.9; }
      100% { transform: translateY(40px); opacity: 0; }
    }

    @keyframes topDrain {
      0%   { transform: scaleY(1); opacity: 1; }
      90%  { transform: scaleY(0.05); opacity: 0.6; }
      100% { transform: scaleY(0); opacity: 0; }
    }

    @keyframes bottomFill {
      0%   { transform: scaleY(0); opacity: 0; }
      10%  { transform: scaleY(0.05); opacity: 0.6; }
      100% { transform: scaleY(1); opacity: 1; }
    }

    @keyframes streamPulse {
      0%   { transform: translateX(-50%) scaleX(1); }
      50%  { transform: translateX(-50%) scaleX(1.2); }
      100% { transform: translateX(-50%) scaleX(1); }
    }

    @keyframes streamFade {
      0%   { opacity: 1; }
      95%  { opacity: 1; }
      100% { opacity: 0; }
    }

    @keyframes shatterOut {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1) rotate(0deg);
        filter: blur(0);
      }
      40% {
        opacity: 1;
        transform: translateY(18px) scale(1.03) rotate(4deg);
        filter: blur(0.4px);
      }
      100% {
        opacity: 0;
        transform: translateY(70px) scale(0.96) rotate(-10deg);
        filter: blur(1.3px);
      }
    }

    @keyframes sandFloorDrain {
      0%   { opacity: 1; transform: scaleY(1); }
      100% { opacity: 0; transform: scaleY(0.1); }
    }

    .title {
      text-align: center;
      font-size: 1.6rem;
      letter-spacing: 0.22em;
      margin-top: 4px;
      text-shadow: 0 0 12px rgba(0, 0, 0, 0.6);
      pointer-events: none;
    }

    .subtitle {
      margin-top: 4px;
      font-size: 0.9rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      opacity: 0.9;
      pointer-events: none;
    }

    .caption {
      margin-top: 10px;
      font-size: 0.75rem;
      max-width: 520px;
      text-align: center;
      line-height: 1.6;
      opacity: 0.9;
      pointer-events: none;
    }

    @media (max-width: 600px) {
      .title { font-size: 1.2rem; }
      .subtitle { font-size: 0.8rem; }
      .caption { font-size: 0.7rem; padding-inline: 8px; }
    }

    .hint {
      position: fixed;
      bottom: 14px;
      right: 18px;
      font-size: 0.7rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      opacity: 0;
      pointer-events: none;
      z-index: 2;
      transition: opacity 0.6s ease;
    }

    .hint.show { opacity: 0.8; }

    .magic-btn {
      position: fixed;
      left: 50%;
      bottom: 72px;
      transform: translate(-50%, 20px);
      padding: 10px 24px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.7);
      background: rgba(10,5,20,0.8);
      color: #fff;
      font-size: 0.9rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      opacity: 0;
      pointer-events: none;
      z-index: 3;
      transition: opacity 0.6s ease, transform 0.6s ease;
      overflow: hidden;
    }

    .magic-btn:hover {
      cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'><line x1='6' y1='28' x2='22' y2='6' stroke='white' stroke-width='3'/><circle cx='23' cy='7' r='4' fill='gold'/></svg>") 0 0, pointer;
    }

    .magic-btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 0% 0%, #ff9df0 0, #c048ff 40%, #2cf5c5 100%);
      transform-origin: left center;
      transform: scaleX(var(--magic-fill, 0));
      transition: transform 0s linear;
      z-index: -1;
    }

    .magic-btn.show {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, 0);
    }

    .wish-btn {
      position: fixed;
      left: 50%;
      top: 372px;
      transform: translate(-50%, -20px);
      padding: 8px 22px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.7);
      background: rgba(10,5,20,0.85);
      color: #fff;
      font-size: 0.85rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      opacity: 0;
      pointer-events: none;
      z-index: 3;
      transition: opacity 0.6s ease, transform 0.6s ease;
      overflow: hidden;
    }
    .wish-btn.show {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

        .wish-btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 0% 0%, rgba(255,255,255,0.8) 0,
                        rgba(255,210,255,0.5) 35%,
                        rgba(120,200,255,0.2) 65%,
                        transparent 100%);
      transform-origin: left center;
      transform: scaleX(var(--wish-fill, 0));
      opacity: 0.9;
      mix-blend-mode: screen;
      pointer-events: none;
    }
    .wish-btn.sparkling::before {
      animation: wishSparkle 0.8s linear infinite;
    }
    @keyframes wishSparkle {
      0%   { filter: blur(0px); }
      50%  { filter: blur(1.2px) brightness(1.2); }
      100% { filter: blur(0px); }
    }

    .fortune {
      position: fixed;
      left: 50%;
      top: 16%;
      transform: translateX(-50%);
      max-width: min(640px, 88vw);
      text-align: center;
      font-size: 1rem;
      line-height: 1.9;
      letter-spacing: 0.08em;
      padding: 14px 20px;
      border-radius: 16px;
      background: rgba(10,5,20,0.65);
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      opacity: 0;
      pointer-events: none;
      z-index: 2;
      transition: opacity 0.8s ease;
      white-space: pre-line;
    }

    body.heaven .fortune {
      background: rgba(255,255,255,0.86);
      color: #402030;
      box-shadow: 0 18px 40px rgba(255,220,255,0.6);
    }

    .fortune.show {
      opacity: 1;
      animation: floatText 4s ease-in-out infinite;
    }

    @keyframes floatText {
      0%   { transform: translateX(-50%) translateY(0); text-shadow: 0 0 14px rgba(255,255,255,0.3); }
      50%  { transform: translateX(-50%) translateY(-6px); text-shadow: 0 0 22px rgba(255,255,255,0.6); }
      100% { transform: translateX(-50%) translateY(0); text-shadow: 0 0 14px rgba(255,255,255,0.3); }
    }

     .flash-overlay {
      position: fixed;
      inset: 0;
      background: rgba(125,255,140,0.22);
      pointer-events: none;
      opacity: 0;
      z-index: 1;
      transition: opacity 1s ease;
    }
    .flash-overlay.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <canvas id="fx"></canvas>
      <div id="flashOverlay" class="flash-overlay"></div>
    <audio id="bgmNormal" src="bgm_normal.mp3" loop></audio>
    <audio id="bgmBattle" src="bgm_battle.mp3" loop></audio>

  <!-- „Åì„Åì„Åã„ÇâËøΩÂä†CSSÔºàUFO„Éë„Ç§„É≠„ÉÉ„ÉàUIÁî®Ôºâ -->
  <style>
    .hg-ui {
      position: fixed;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      z-index: 3;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease;
    }
    .hg-ui.show {
      opacity: 1;
    }
    .hg-timer {
      font-size: 0.9rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      text-shadow: 0 0 12px rgba(0,0,0,0.8);
    }
    .hg-hp-shell {
      width: 160px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      overflow: hidden;
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
    }
    .hg-hp-bar {
      width: 100%;
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg,#6ff3ff,#ffeb8a,#ff6f91);
      transition: width 0.25s ease;
    }

    .ufo-hud {
      position: fixed;
      left: 18px;
      bottom: 18px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(8,6,18,0.85);
      border: 1px solid rgba(255,255,255,0.3);
      font-size: 0.7rem;
      line-height: 1.6;
      max-width: 260px;
      z-index: 3;
      pointer-events: none;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.4s ease, transform 0.4s ease;
    }
    .ufo-hud.show {
      opacity: 0.9;
      transform: translateY(0);
    }
    .ufo-hud-title {
      font-size: 0.72rem;
      letter-spacing: 0.18em;
      margin-bottom: 4px;
      opacity: 0.9;
    }
    .ufo-hud-keys span {
      display: block;
      opacity: 0.88;
    }
    .ufo-hud-shield {
      margin-top: 4px;
      height: 3px;
      width: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg,rgba(180,255,255,0.5),rgba(120,200,255,0.1));
      overflow: hidden;
      opacity: 0.3;
    }
    .ufo-hud-shield::before {
      content: "";
      display: block;
      height: 100%;
      width: 100%;
      transform-origin: left center;
      transform: scaleX(var(--shield-ratio, 0));
      background: linear-gradient(90deg,#2cf5c5,#8bd5ff,#ffffff);
      transition: transform 0.25s ease;
    }

    .ufo-message {
      position: fixed;
      left: 50%;
      top: 24%;
      transform: translateX(-50%) translateY(-8px);
      padding: 10px 18px;
      border-radius: 999px;
      background: rgba(15,10,30,0.88);
      border: 1px solid rgba(255,255,255,0.6);
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      z-index: 4;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      white-space: nowrap;
    }
    .ufo-message.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    .ufo-message.fade {
      opacity: 0;
      transform: translateX(-50%) translateY(4px);
    }

    @media (max-width: 600px) {
      .ufo-hud { max-width: 220px; font-size: 0.65rem; }
      .hg-ui { transform: translate(-50%, -40%); }
    }
  </style>
  <!-- ËøΩÂä†CSS„Åì„Åì„Åæ„Åß -->

  <div class="scene" id="scene">
    <div class="hourglass-wrapper">
      <div class="hourglass" id="hourglass">
        <div class="plate plate-top"></div>
        <div class="plate plate-bottom"></div>

        <div class="glass" id="glass"></div>
        <div class="hourglass-outline" id="hgOutline"></div>

        <div class="sand-top" id="sandTop"></div>
        <div class="sand-bottom" id="sandBottom"></div>
        <div class="sand-stream" id="sandStream"></div>
        <div class="sand-particles" id="sandParticles">
          <span></span><span></span><span></span><span></span>
        </div>

        <div class="sand-floor" id="sandFloor"></div>
        <div class="crack-layer" id="cracks"></div>
      </div>

      <div class="title">Á†ÇÊôÇË®à„Åø„Åè„Åò</div>
      <div class="subtitle">ANOTHER MOON ‚Ä¢ B SIDE OF YOUR WORLD</div>
      <p class="caption">
        30Áßí„ÅÆ„ÅÇ„ÅÑ„Å†„ÄÅÂ§úÁ©∫„ÇíÊµÅ„Çå„ÇãÊòü„Åå<br>
        „ÅÑ„Åè„Å§„ÄÅ„ÅÇ„Å™„Åü„ÅÆÊôÇÈñì„ÇíÊè∫„Çâ„Åô„Åß„Åó„Çá„ÅÜ„ÄÇ<br>
        „Å≤„Å≥„ÅÆÊï∞„Å†„Åë„ÄÅ‰ªäÊó•„ÅÆÁâ©Ë™û„ÅåÂ∞ë„ÅóÂ§â„Çè„Çä„Åæ„Åô„ÄÇ
      </p>
    </div>
  </div>

<!-- „Çø„ÉÉ„ÉÅÁ´ØÊú´Áî®‰ªÆÊÉ≥„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÔºàËøΩÂä†CSSÔºâ -->
  <style>
    .touch-controller {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 30vh;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: 5;
    }
    
    .touch-controller.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    .dpad-container {
      position: relative;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: rgba(10, 5, 20, 0.75);
      backdrop-filter: blur(8px);
      box-shadow: 
        0 8px 24px rgba(0, 0, 0, 0.6),
        inset 0 0 24px rgba(255, 255, 255, 0.15);
      touch-action: manipulation;
    }
    
    .dpad-center {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      z-index: 1;
    }
    
    .dpad-btn {
      position: absolute;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: rgba(40, 30, 60, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.9);
      font-size: 1.4rem;
      transition: all 0.12s ease;
      z-index: 2;
      border: 2px solid rgba(255, 255, 255, 0.2);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    
    .dpad-btn.active {
      background: rgba(80, 120, 255, 0.9);
      transform: scale(0.88);
      border-color: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 20px rgba(100, 150, 255, 0.8);
    }
    
    .dpad-up {
      left: 50%;
      top: 10px;
      transform: translateX(-50%);
    }
    .dpad-left {
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    .dpad-down {
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
    }
    .dpad-right {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      touch-action: manipulation;
    }
    
    .action-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(40, 30, 60, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      transition: all 0.12s ease;
      border: 2px solid rgba(255, 255, 255, 0.2);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    
    .action-btn.active {
      transform: scale(0.88);
      border-color: rgba(255, 255, 255, 0.8);
    }
    
    .barrier-btn.active {
      background: rgba(80, 200, 255, 0.9);
      box-shadow: 0 0 20px rgba(80, 200, 255, 0.8);
    }
    
    .beam-btn.active {
      background: rgba(255, 100, 100, 0.9);
      box-shadow: 0 0 20px rgba(255, 100, 100, 0.8);
    }
    
    .action-btn-icon {
      font-size: 1.4rem;
      margin-bottom: 4px;
    }
    
    @media (max-width: 600px) {
      .touch-controller {
        height: 35vh;
        padding: 15px;
      }
      
      .dpad-container {
        width: 120px;
        height: 120px;
      }
      
      .dpad-btn {
        width: 46px;
        height: 46px;
        font-size: 1.2rem;
      }
      
      .action-btn {
        width: 60px;
        height: 60px;
        font-size: 0.65rem;
      }
    }
    
    @media (max-width: 400px) {
      .touch-controller {
        flex-direction: column;
        justify-content: flex-end;
        gap: 15px;
      }
      
      .action-buttons {
        flex-direction: row;
        gap: 20px;
      }
    }
  </style>

  <!-- ‰ªÆÊÉ≥„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºHTML -->
  <div id="touchController" class="touch-controller">
    <div class="dpad-container">
      <div class="dpad-center"></div>
      <div class="dpad-btn dpad-up" data-key="KeyW">‚Üë</div>
      <div class="dpad-btn dpad-left" data-key="KeyA">‚Üê</div>
      <div class="dpad-btn dpad-down" data-key="KeyS">‚Üì</div>
      <div class="dpad-btn dpad-right" data-key="KeyD">‚Üí</div>
    </div>
    
    <div class="action-buttons">
      <div class="action-btn barrier-btn" data-key="Space">
        <div class="action-btn-icon">üõ°Ô∏è</div>
        <div>„Éê„É™„Ç¢</div>
      </div>
      <div class="action-btn beam-btn" data-key="KeyB">
        <div class="action-btn-icon">‚ö°</div>
        <div>„Éì„Éº„É†</div>
      </div>
    </div>
  </div>

  <div id="fortune" class="fortune"></div>
  <button id="magicButton" class="magic-btn">È≠îÊ≥ï„Çí„Åã„Åë„Å¶ÔºÅ</button>
  <button id="wishButton" class="wish-btn">È°ò„ÅÑ„Çí„ÅäËä±„Å´Ëæº„ÇÅ„Çã</button>
  <div class="hint" id="hint">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÄÅÊôÇÈñì„Å´È≠îÊ≥ï„Çí„Åã„Åë„ÇãÔºü</div>

  <script>
    const bgmNormal = document.getElementById('bgmNormal');
    const bgmBattle = document.getElementById('bgmBattle');
    let bgmInitialized = false;
    let bgmMode = 'none';

    function setBgmMode(mode) {
      if (!bgmNormal || !bgmBattle) return;
      if (mode === bgmMode) return;
      bgmMode = mode;

      if (mode === 'normal') {
        bgmBattle.pause();
        bgmNormal.volume = 0.6;
        bgmNormal.play().catch(()=>{});
      } else if (mode === 'battle') {
        bgmNormal.pause();
        bgmBattle.volume = 0.7;
        bgmBattle.play().catch(()=>{});
      } else {
        bgmNormal.pause();
        bgmBattle.pause();
      }
    }

    // ÊúÄÂàù„ÅÆ„É¶„Éº„Ç∂„ÉºÊìç‰Ωú„Åß BGM „ÇíÊúâÂäπÂåñ
(function setupBgmAutoStart(){
  function onFirstInteraction(){
    if (bgmInitialized) return;
    bgmInitialized = true;
    setBgmMode('normal');  // ÈÄöÂ∏∏BGM„Çπ„Çø„Éº„Éà
    document.removeEventListener('click', onFirstInteraction);
    document.removeEventListener('touchstart', onFirstInteraction);
  }
  document.addEventListener('click', onFirstInteraction);
  document.addEventListener('touchstart', onFirstInteraction, { passive: true });
})();
  </script>

  <!-- ÂÖÉ„ÅÆ„É°„Ç§„É≥„Çπ„ÇØ„É™„Éó„ÉàÔºà„Åù„ÅÆ„Åæ„ÅæÔºâ -->
  <script>
    const canvas = document.getElementById('fx');
    const ctx = canvas.getContext('2d');
    let w = window.innerWidth;
    let h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
„ÄÄ„ÄÄ// „Çπ„Éû„ÉõÊìç‰ΩúÊôÇ„ÅÆ„Éñ„É©„Ç¶„Ç∂Ê®ôÊ∫ñ„Ç∏„Çß„Çπ„ÉÅ„É£Ôºà„Çπ„ÇØ„É≠„Éº„É´/Êã°Â§ßÔºâ„ÇíÊäëÂà∂„Åó„Å¶„Ç≤„Éº„É†Êìç‰Ωú„ÇíÂÑ™ÂÖà
„ÄÄ„ÄÄcanvas.style.touchAction = 'none';

    window.addEventListener('resize', () => {
      w = window.innerWidth;
      h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;
      if (heavenMode) {
        initHeavenCraters();
        initHeavenTree();
      }
    });

    const palette = [
      getComputedStyle(document.documentElement).getPropertyValue('--palette-1').trim(),
      getComputedStyle(document.documentElement).getPropertyValue('--palette-2').trim(),
      getComputedStyle(document.documentElement).getPropertyValue('--palette-3').trim(),
      getComputedStyle(document.documentElement).getPropertyValue('--palette-4').trim(),
      getComputedStyle(document.documentElement).getPropertyValue('--palette-5').trim(),
      getComputedStyle(document.documentElement).getPropertyValue('--palette-6').trim(),
      getComputedStyle(document.documentElement).getPropertyValue('--palette-7').trim(),
      getComputedStyle(document.documentElement).getPropertyValue('--palette-8').trim()
    ];

    const FORTUNE_0 = '‰ªäÊó•„ÅÆ„ÅÇ„Å™„Åü„ÅØÊúÄÂº∑„Å†„Çà„ÄÇ\nÊúà„ÅÆ„ÅîÂä†Ë≠∑„Åå„ÅÇ„Çâ„Çì„Åì„Å®„Å´„ÄÇ';
    const FORTUNE_1 = '‰∏çÂÆåÁíß„Å™‰∫∫Áîü„Åì„Åù„ÄÅÈù¢ÁôΩ„Åø„Åå„ÅÇ„Çã„ÄÇ\n‰ªäÊó•„ÇÇ„Çè„Åè„Çè„ÅèÊ∫ÄËºâ„ÅÆ‰∏ÄÊó•„Åß„ÅÇ„Çã„Çà„ÅÜ„Å´ÔºÅ';
    const FORTUNE_2 = 'Âº∑ÈÅã„ÅÆ„Å§„ÅÑ„Å¶„ÅÑ„Çã„ÅÇ„Å™„Åü„ÅØÁõ∏ÂΩì„Çø„Éï„Å†„Åã„Çâ„ÄÅ\nËá™ÂàÜ„Çí‰ø°„Åò„Å¶ÔºÅ';
    const FORTUNE_3 = '„Çà„Åè„Å™„ÅÑ„Åì„Å®„ÇÑÈõëÈü≥„ÅØ„Åô„Åπ„Å¶ÊôÇ„Å®„Å®„ÇÇ„Å´Ê∂à„Åà„Å¶„ÅÑ„Å£„ÅüÔºÅ\n„ÅÇ„Å™„Åü„ÅØÁîü„Åæ„ÇåÂ§â„Çè„Å£„Åü„ÄÇ';

    let moonNormX = 0.78;
    let moonNormY = 0.18;
    let moonHue = 240;
    let moonSat = 80;
    let moonLight = 70;
    let heavenMode = false;
    let heavenReveal = 0;
    let treeGrowth = 0;

// ‚òÖ ËøΩÂä†ÔºöÂ§©ÂõΩÊºîÂá∫Áî®„ÅÆÁä∂ÊÖã
    let heavenTreePattern = 1;
    let extraFlowers = [];        // Ëä±„ÅÆÊµ∑„ÅÆËøΩÂä†„ÅÆËä±
    let flowerSeaActive = false;  // Ëä±„ÅÆÊµ∑„É¢„Éº„Éâ ON
    let flowerSeaCountGoal = 80;  // „Äå2/3„Åê„Çâ„ÅÑË¶Ü„ÅÜ„ÄçÁõÆÂÆâ
    let flowerSpawnTicker = 0;    // Ëä±„ÇíÁîü„ÇÑ„Åô„É™„Ç∫„É†Áî®
    let flowerWishAvailable = false;

    let mainFlowerCenter = { x: 0, y: 0, r: 0 }; // „É°„Ç§„É≥„ÅÆËä±„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö
    let mainFlowerHovered = false;
const WIND_CURSOR =
  "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'>" +
  "<line x1='6' y1='28' x2='22' y2='6' stroke='white' stroke-width='3'/>" +
  "<circle cx='23' cy='7' r='4' fill='gold'/>" +
  "</svg>\") 0 0, pointer"

    let petals = [];              // Ëä±ÂêπÈõ™„ÅÆËä±„Å≥„Çâ
    let petalStormActive = false; // Ëä±ÂêπÈõ™„Ç¢„Éã„É° ON

    // ‚òÖ Êúà„ÅÆ„Éï„Çß„Éº„ÉâÔºÜÂÜçË™ïÊºîÂá∫Áî®
    let moonFade = 0;
    let moonRebirth = 0;

    let hourglassNormX = 0.5;
    let hourglassNormY = 0.5;

        // ‚òÖ ËøΩÂä†ÔºöÂÖ®‰ΩìÊôÇÈñìÔºÜÊúà„ÅÆ‰∏ä‰∏ã„ÇÜ„Çâ„Åé
    let globalTime = 0;
    function getMoonPosition() {
      const wobble = Math.sin(globalTime * 0.0009) * h * 0.018; // ‰∏ä‰∏ã„Å´„Åî„ÅèËªΩ„Åè„ÇÜ„Çâ„Åê
      return {
        x: w * moonNormX,
        y: h * moonNormY + wobble
      };
    }

    const stars = [];
    const windPixels = [];
    const shootingStars = [];
    let starsSuspended = false;

    const starCount = 120;
    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: Math.random() * w,
        y: Math.random() * h,
        size: 1 + Math.random() * 2,
        alpha: 0.3 + Math.random() * 0.7,
        speed: 0.1 + Math.random() * 0.4,
        twinkle: Math.random() * Math.PI * 2
      });
    }

    for (let i = 0; i < 40; i++) {
      windPixels.push({
        x: Math.random() * w,
        y: Math.random() * h,
        w: 10 + Math.random() * 40,
        hh: 2 + Math.random() * 4,
        speed: 0.4 + Math.random() * 1,
        alpha: 0.1 + Math.random() * 0.3,
        color: palette[Math.floor(Math.random() * palette.length)]
      });
    }

    let moonDots = [];
    function initMoonDots() {
      moonDots = [];
      for (let i = 0; i < 14; i++) {
        const rRatio = 0.15 + Math.random() * 0.4;
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.00005 + Math.random() * 0.00015;
        const size = 2 + Math.random() * 2;
        moonDots.push({ rRatio, angle, speed, size });
      }
    }
    function updateMoonDots(dt) {
      for (let d of moonDots) {
        d.angle += d.speed * dt;
      }
    }

    let heavenCraters = [];
    function initHeavenCraters() {
      heavenCraters = [];
      const baseY = h * 0.7;
      for (let i = 0; i < 7; i++) {
        const rx = (w / 2) + (Math.random() - 0.5) * w * 0.6;
        const ry = baseY + Math.random() * h * 0.25;
        const rr = 20 + Math.random() * 60;
        const rot = Math.random() * Math.PI;
        heavenCraters.push({ rx, ry, rr, rot });
      }
    }

    let heavenTree = null;
    function initHeavenTree() {
  // ÁÆÄÂçï‰ªô‰∫∫Êéå/ÊùæÊ†ëÈ£éÊ†º
  const baseXNorm = 0.24 + Math.random() * 0.2;
  const baseY = h * 0.7;
  const trunkHeight = h * (0.18 + Math.random() * 0.08);
  
  // ‰∏ªÂπ≤ÔºàÁÆÄÂçïÁõ¥Á∫øÔºâ
  const trunk = [
    { x: w * baseXNorm, y: baseY, width: 60 },
    { x: w * baseXNorm, y: baseY - trunkHeight * 0.5, width: 45 },
    { x: w * baseXNorm, y: baseY - trunkHeight, width: 30 }
  ];
  
  // ÁÆÄÂçïÂàÜÊîØÔºà‰ªô‰∫∫ÊéåÁöÑÂàÜËäÇÊÑüÔºâ
  const branches = [];
  const leaves = [];
  
  // ‰∏ªÂπ≤‰∏äÁöÑËäÇ
  for (let i = 1; i < 3; i++) {
    const yPos = baseY - (trunkHeight * i) / 3;
    const side = Math.random() < 0.5 ? -1 : 1;
    
    // ÁÆÄÂçï‰æßÊûùÔºàÁü≠Â∞èÔºâ
    branches.push({
      x0: w * baseXNorm,
      y0: yPos,
      x1: w * (baseXNorm + side * 0.05),
      y1: yPos - h * 0.05,
      width: 25
    });
    
    // Âú®Â∞èÊûùÈ°∂Á´ØÊ∑ªÂä†Âè∂/Ëä±
    leaves.push({
      x: w * (baseXNorm + side * 0.05),
      y: yPos - h * 0.05,
      radius: 6 + Math.random() * 4,
      phase: Math.random() * Math.PI * 2
    });
  }
  
  // È°∂ÈÉ®ÁöÑÂ∞èËä±Á∞á
  for (let i = 0; i < 4; i++) {
    const angle = (Math.PI * 2 * i) / 4;
    const offsetX = Math.cos(angle) * 15;
    const offsetY = Math.sin(angle) * 10;
    leaves.push({
      x: w * baseXNorm + offsetX,
      y: baseY - trunkHeight + offsetY,
      radius: 5 + Math.random() * 3,
      phase: Math.random() * Math.PI * 2
    });
  }

  heavenTree = {
    pattern: 1, // Âõ∫ÂÆö‰∏∫ÁÆÄÂçï‰ªô‰∫∫ÊéåÈ£éÊ†º
    trunk,
    branches,
    leaves,
    baseY,
    trunkHeight
  };
}

// ÊõøÊç¢ drawHeavenTree ÂáΩÊï∞
function drawHeavenTree() {
  if (!heavenTree) return;
  const g = heavenTree;
  const tG = treeGrowth; // 0„Äú1ÔºàÊàêÈï∑Â∫¶Ôºâ

  ctx.save();
  
  // ‰ªô‰∫∫Êéå/ÊùæÊ†ëÁöÑÈ¢úËâ≤
  let trunkColor = 'rgba(80, 120, 80, 0.95)'; // ÁªøËâ≤Á≥ªÊ†ëÂπ≤
  let leafMain   = 'rgba(180, 220, 150, 0.85)'; // ÊµÖÁªøËâ≤Âè∂Â≠ê
  let leafSub    = 'rgba(255, 230, 180, 0.9)'; // ÊµÖÈªÑËâ≤ÁÇπÁºÄ

  // Ê†ëÂπ≤
  ctx.strokeStyle = trunkColor;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = 8 * tG;
  
  // ÁªòÂà∂‰∏ªÂπ≤ÔºàÁÆÄÂçïÁõ¥Á∫øÔºâ
  ctx.beginPath();
  ctx.moveTo(g.trunk[0].x, g.trunk[0].y);
  for (let i = 1; i < g.trunk.length; i++) {
    ctx.lineTo(g.trunk[i].x, g.trunk[i].y);
  }
  ctx.stroke();
  
  // ÁªòÂà∂ÂàÜÊîØ
  ctx.lineWidth = 5 * tG;
  for (let b of g.branches) {
    ctx.beginPath();
    ctx.moveTo(b.x0, b.y0);
    ctx.lineTo(b.x1, b.y1);
    ctx.stroke();
  }
  
  // ÁªòÂà∂Âè∂Â≠ê/Â∞èËä±
  for (let leaf of g.leaves) {
    const t = performance.now() * 0.001 + leaf.phase;
    const offX = Math.sin(t) * 2 * tG;
    const offY = Math.cos(t * 1.2) * 2 * tG;
    const r = leaf.radius * tG;
    
    const lx = leaf.x + offX;
    const ly = leaf.y + offY;
    
    // ÁÆÄÂçïÂúÜÂΩ¢Âè∂Â≠ê
    const grad = ctx.createRadialGradient(lx, ly, 0, lx, ly, r);
    grad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
    grad.addColorStop(0.4, leafMain);
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(lx, ly, r, 0, Math.PI * 2);
    ctx.fill();
    
    // ÂÅ∂Â∞îÊ∑ªÂä†Â∞èÁÇπÁºÄ
    if (Math.random() < 0.2 * tG) {
      ctx.fillStyle = leafSub;
      ctx.beginPath();
      ctx.arc(lx + (Math.random() - 0.5) * 4, ly + (Math.random() - 0.5) * 4, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}

    function randomizeMoon() {
      moonNormX = 0.2 + Math.random() * 0.6;
      moonNormY = 0.08 + Math.random() * 0.22;
      moonHue = 200 + Math.random() * 160;
      moonSat = 60 + Math.random() * 25;
      moonLight = 60 + Math.random() * 15;
    }

    let ufo = null;
    let ufoPilotMode = false;  // ‚òÖËøΩÂä†
    function maybeSpawnUfo() {
      if (ufo || heavenMode) return;
      if (Math.random() < 0.0006) {
        const edge = ['left','right','top','bottom'][Math.floor(Math.random()*4)];
        let x, y, angleDeg;
        if (edge === 'left') {
          x = -80; y = h*(0.2+Math.random()*0.5);
          angleDeg = -20 + Math.random()*40;
        } else if (edge === 'right') {
          x = w+80; y = h*(0.2+Math.random()*0.5);
          angleDeg = 160 + Math.random()*40;
        } else if (edge === 'top') {
          x = Math.random()*w; y = -80;
          angleDeg = 60 + Math.random()*60;
        } else {
          x = Math.random()*w; y = h+80;
          angleDeg = -120 + Math.random()*60;
        }
        const speed = 0.15;
        const rad = angleDeg * Math.PI/180;
        const baseVX = Math.cos(rad)*speed;
        const baseVY = Math.sin(rad)*speed;

        const pattern = ['zigzag','wave','loop'][Math.floor(Math.random()*3)];
        const type = ['ring','dish','spike'][Math.floor(Math.random()*3)];

        ufo = {
          x, y,
          baseVX, baseVY,
          pattern,
          type,
          t: 0,
          pauseTimer: 0,
          baseY: y,
          baseX: x,
          scale: 0.6 + Math.random()*0.6,
          currScale: 1,
          depthPhase: Math.random()*Math.PI*2
        };
      }
    }

    function updateUfo(dt) {
      if (!ufo) return;
      ufo.t += dt;
      ufo.depthPhase += dt * 0.0015;

      if (ufo.pauseTimer > 0) {
        ufo.pauseTimer -= dt;
      } else {
        ufo.x += ufo.baseVX * dt;
        ufo.y += ufo.baseVY * dt;

        if (ufo.pattern === 'zigzag') {
          const wobbleX = Math.sin(ufo.t*0.004)*20;
          const wobbleY = Math.sin(ufo.t*0.0031 + 1.1)*26;
          ufo.x += wobbleX*0.04;
          ufo.y += wobbleY*0.04;
        } else if (ufo.pattern === 'wave') {
          const wX = Math.sin(ufo.t*0.0024)*30;
          const wY = Math.cos(ufo.t*0.0037)*18;
          ufo.x += wX*0.03;
          ufo.y += wY*0.03;
        } else if (ufo.pattern === 'loop') {
          const r = 22 + Math.sin(ufo.t*0.002)*10;
          const ang = ufo.t*0.004;
          ufo.x += Math.cos(ang)*r*0.004;
          ufo.y += Math.sin(ang)*r*0.004;
        }

        if (Math.random() < 0.0015) {
          ufo.pauseTimer = 400 + Math.random()*1400;
        }
      }

      const depth = 0.5 + 0.5*Math.sin(ufo.depthPhase);
      ufo.currScale = ufo.scale*(0.7+0.6*depth);

      if (ufo.x < -150 || ufo.x > w+150 || ufo.y < -150 || ufo.y > h+150 || ufo.t > 25000) {
        ufo = null;
      }
    }

    function drawUfo() {
      if (!ufo) return;
      ctx.save();
      ctx.translate(ufo.x, ufo.y);
      ctx.scale(ufo.currScale, ufo.currScale);
      let bodyW = 60, bodyH = 18;
      const depthAlpha = 0.6 + 0.4 * (ufo.currScale / (ufo.scale + 0.0001));
      ctx.globalAlpha = depthAlpha;

      if (ufo.type === 'ring') {
        ctx.fillStyle = 'rgba(200,220,255,0.95)';
        ctx.beginPath();
        ctx.ellipse(0,0,bodyW,bodyH,0,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(120,200,255,0.9)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(0,0,bodyW-6,bodyH-4,0,0,Math.PI*2);
        ctx.stroke();
        ctx.fillStyle = 'rgba(160,190,255,0.95)';
        ctx.beginPath();
        ctx.ellipse(0,-12,22,16,0,0,Math.PI*2);
        ctx.fill();
      } else if (ufo.type === 'dish') {
        ctx.fillStyle = 'rgba(180,230,255,0.95)';
        ctx.beginPath();
        ctx.ellipse(0,0,bodyW*0.9,bodyH*1.2,0,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(140,200,255,0.95)';
        ctx.beginPath();
        ctx.ellipse(0,-10,18,14,0,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(-6,-20,12,8);
      } else {
        ctx.fillStyle = 'rgba(220,210,255,0.95)';
        ctx.beginPath();
        ctx.ellipse(0,0,bodyW*0.8,bodyH*1.1,0,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(170,140,255,0.95)';
        ctx.beginPath();
        ctx.ellipse(0,-14,16,18,0,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.moveTo(-10,-26);
        ctx.lineTo(-6,-18);
        ctx.moveTo(10,-26);
        ctx.lineTo(6,-18);
        ctx.stroke();
      }

      const lights = 5;
      for (let i = 0; i < lights; i++) {
        const lx = -bodyW * 0.7 + (i / (lights - 1)) * bodyW * 1.4;
        ctx.fillStyle = i % 2 === 0 ? 'rgba(255,240,180,0.95)' : 'rgba(180,255,220,0.95)';
        ctx.beginPath();
        ctx.arc(lx, bodyH * 0.3, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      // ‚òÖ „Éë„Ç§„É≠„ÉÉ„Éà„É¢„Éº„Éâ‰∏≠„Å†„Åë„ÄÅÂÜÜÁõ§‰∏≠Â§Æ„ÅåËµ§„ÅèÁÇπÊªÖ
      if (ufoPilotMode) {
        const pulse = 0.4 + 0.6 * Math.sin(ufo.t * 0.01);
        ctx.save();
        ctx.globalAlpha = pulse;
        ctx.fillStyle = 'rgba(255,80,80,0.95)';
        ctx.beginPath();
        // ÂÜÜÁõ§„ÅÆ„ÇÑ„ÇÑ‰∏ä„ÅÇ„Åü„Çä„Å´Â∞è„Åï„Å™Ëµ§„ÅÑ„É©„É≥„Éó
        ctx.arc(0, bodyH * 0.1, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function drawBackground(dt) {
    const bgSpeedFactor = ufoPilotMode ? 9 : 1;  // ‚òÖ UFO„Ç§„Éô„É≥„Éà‰∏≠„ÅØ 9 ÂÄçÈÄü
      const g = ctx.createRadialGradient(
        w * 0.5, h * 0.1, 0,
        w * 0.5, h * 0.5, Math.max(w, h)
      );
      g.addColorStop(0, '#1f1b3b');
      g.addColorStop(0.4, '#05030f');
      g.addColorStop(1, '#02010a');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      if (!heavenMode) {
        const { x: moonX, y: moonY } = getMoonPosition();
        const baseR = Math.min(w, h) * 0.09;

        // ‚òÖ Ë°®Á§∫Â∫¶„Éª„Çµ„Ç§„Ç∫„Çí„É¢„Éº„Éâ„Åî„Å®„Å´Âàá„ÇäÊõø„Åà
        let alphaFactor = 1;
        let sizeFactor = 1;

        if (fxMode === 'idle') {
          // ÈÄöÂ∏∏ÊôÇÔºömoonFade „Åß„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„ÉàÔºà0 ‚Üí 1Ôºâ
          const f = Math.max(0, Math.min(1, moonFade));
          alphaFactor = 1 - f;
        } else if (fxMode === 'swirl') {
          // „Éî„ÇØ„Çª„É´Ê∏¶„ÅÆÁµÇÁõ§ÔºömoonRebirth „ÅßÂÜçË™ïÔºà0 ‚Üí 1Ôºâ
          const r = Math.max(0, Math.min(1, moonRebirth));
          alphaFactor = r;
          sizeFactor = 0.4 + 0.6 * r; // Âá∫ÁèæÁõ¥Âæå„ÅØÂ∞ë„ÅóÂ∞è„Åï„ÇÅ ‚Üí ÊúÄÁµÇÁöÑ„Å´Á≠âÂÄç
        } else {
          // explode / float ‰∏≠„ÅØÊúà„ÅØË°®Á§∫„Åó„Å™„ÅÑ
          alphaFactor = 0.00;
        }

        if (alphaFactor > 0.01) {
          const moonR = baseR * sizeFactor;

          ctx.save();
          ctx.translate(moonX, moonY);

          for (let r = moonR; r > 0; r -= 4) {
            const t = r / moonR;
            const light = moonLight + (1 - t) * 12;
            const alpha = (0.06 + 0.16 * t) * alphaFactor;
            ctx.fillStyle = `hsla(${moonHue}, ${moonSat}%, ${light}%, ${alpha})`;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();
          }

          for (let d of moonDots) {
            const rr = moonR * d.rRatio;
            const px = Math.cos(d.angle) * rr;
            const py = Math.sin(d.angle) * rr;
            ctx.fillStyle = `hsla(${moonHue}, ${moonSat - 10}%, ${moonLight - 15}%, ${0.65 * alphaFactor})`;
            ctx.beginPath();
            ctx.arc(px, py, d.size, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }
      }

      for (let s of stars) {
        s.y += s.speed * 0.2 * bgSpeedFactor;
        if (s.y > h) s.y = -10;
        s.twinkle += 0.02;
        const tw = 0.5 + 0.5 * Math.sin(s.twinkle);
        ctx.globalAlpha = s.alpha * tw;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(Math.round(s.x), Math.round(s.y), s.size, s.size);
      }
      ctx.globalAlpha = 1;

      for (let p of windPixels) {
        p.x += p.speed * bgSpeedFactor;
        if (p.x - p.w > w) {
          p.x = -p.w;
          p.y = Math.random() * h;
          p.w = 10 + Math.random() * 40;
          p.hh = 2 + Math.random() * 4;
          p.speed = 0.4 + Math.random() * 1;
          p.color = palette[Math.floor(Math.random() * palette.length)];
        }
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(Math.round(p.x), Math.round(p.y), p.w, p.hh);
      }
      ctx.globalAlpha = 1;
 if (heavenMode) {
        ctx.save();

        // ‚òÖ ÊúàÈù¢„ÅØÁîªÈù¢ÈÅ©Âàá„Å™Â§ß„Åç„Åï
        const revealHeight = h  * heavenReveal;
        ctx.beginPath();
        ctx.rect(0, h - revealHeight, w, revealHeight);
        ctx.clip();

        const moonSurfRadius = h * 0.7;
        const moonSurfCx = w / 2;
        const moonSurfCy = h + moonSurfRadius * 0.32;

        const mg = ctx.createRadialGradient(
          moonSurfCx, moonSurfCy, moonSurfRadius * 0.2,
          moonSurfCx, moonSurfCy, moonSurfRadius
        );
        mg.addColorStop(0, 'rgba(255,255,255,0.95)');
        mg.addColorStop(0.4, 'rgba(245,240,255,0.95)');
        mg.addColorStop(1, 'rgba(210,210,230,0.9)');
        ctx.fillStyle = mg;
        ctx.beginPath();
        ctx.arc(moonSurfCx, moonSurfCy, moonSurfRadius, Math.PI, 2 * Math.PI);
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        ctx.fill();

        // „ÇØ„É¨„Éº„Çø„Éº
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = 'rgba(180,180,200,1)';
        for (let c of heavenCraters) {
          ctx.beginPath();
          ctx.ellipse(c.rx, c.ry, c.rr, c.rr * 0.6, c.rot, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Êú®Ôºà3„Éë„Çø„Éº„É≥ÂØæÂøúÁâàÔºâ
        drawHeavenTree();

        // ===== „É°„Ç§„É≥„ÅÆËä±„Å®Ëä±„ÅÆÊµ∑ =====
const flowerX = w * 0.62;
const flowerBaseY = h * 0.74;
const stemH = h * 0.09;
const centerY = flowerBaseY - stemH - 6;
const petalR = 8;

// „ÇØ„É™„ÉÉ„ÇØÂà§ÂÆöÁî®„ÅÆ‰∏≠ÂøÉ
mainFlowerCenter.x = flowerX;
mainFlowerCenter.y = centerY;
mainFlowerCenter.r = petalR * 2.2;

// Ëä±„Çí1Êú¨Êèè„Åè„Éò„É´„Éë„Éº
// ÊõøÊç¢ drawSingleFlower ÂáΩÊï∞‰∏≠ÁöÑËä±Áì£ÁªòÂà∂ÈÉ®ÂàÜ
function drawSingleFlower(x, baseY, scale, type, tOffset = 0, isMain = false) {
  const s = scale || 1;
  const localStemH = stemH * s * (0.7 + treeGrowth * 0.6);
  const centerYLocal = baseY - localStemH - 6 * s;

  ctx.save();
  ctx.translate(x, 0);

  // ËåéÁöÑËâ≤
  if (type === 3) ctx.strokeStyle = 'rgba(150,170,120,0.95)';
  else if (type === 2) ctx.strokeStyle = 'rgba(120,150,190,0.95)';
  else ctx.strokeStyle = 'rgba(150,110,140,0.95)';

  ctx.lineWidth = 2 * s;

  // È£é„Å´„Çà„Çã„Åó„Å™„Çä
  const windT = performance.now() * 0.0018 + tOffset;
  const windAmp = isMain ? (mainFlowerHovered ? 10 : 6) : 3;
  const sway = Math.sin(windT) * windAmp;

  ctx.beginPath();
  ctx.moveTo(0, baseY);
  ctx.quadraticCurveTo(
    -sway * 0.2,
    baseY - localStemH * 0.4,
    sway * 0.25,
    baseY - localStemH
  );
  ctx.stroke();

  // ‰æßÂè∂
  ctx.beginPath();
  ctx.ellipse(
    -8 * s + sway * 0.1,
    baseY - localStemH * 0.5,
    8 * s,
    4 * s,
    -0.5,
    0,
    Math.PI * 2
  );
  ctx.stroke();

  // Ëä±„Å≥„Çâ - Ê∑ªÂä†ÊãÇÂä®ÊïàÊûú
  let petalColor = 'rgba(255,140,220,0.95)';
  if (type === 2) petalColor = 'rgba(180,210,255,0.95)';
  if (type === 3) petalColor = 'rgba(255,230,190,0.95)';
  ctx.fillStyle = petalColor;

  // Ëä±Áì£ÊãÇÂä®ÊïàÊûú - ÊØè‰∏™Ëä±Áì£ÈÉΩÊúâËΩªÂæÆÁöÑÁã¨Á´ãÊôÉÂä®
  const petalFlutterTime = performance.now() * 0.002 + tOffset;
  
  const basePetalR = petalR * s * (isMain ? 1.2 : 1);
  for (let i = 0; i < 5; i++) {
    // ÊØè‰∏™Ëä±Áì£Êúâ‰∏çÂêåÁöÑÊôÉÂä®Áõ∏‰Ωç
    const petalOffset = (i / 5) * Math.PI * 2;
    const flutter = Math.sin(petalFlutterTime + petalOffset) * 0.2;
    const flutterScale = 0.9 + Math.sin(petalFlutterTime * 1.3 + petalOffset) * 0.1;
    
    const ang = (Math.PI * 2 * i) / 5 + flutter;
    const px = Math.cos(ang) * basePetalR;
    const py = Math.sin(ang) * basePetalR;

    ctx.save();
    ctx.translate(px, centerYLocal + py);
    ctx.rotate(flutter * 0.5); // ËΩªÂæÆÊóãËΩ¨
    
    // Ëä±Áì£ÂΩ¢Áä∂Á®çÂæÆÂèòÂΩ¢Ê®°ÊãüÊãÇÂä®
    ctx.beginPath();
    ctx.ellipse(
      0, 0,
      7 * s * flutterScale,
      11 * s * (1.1 - flutter * 0.2),
      ang,
      0,
      Math.PI * 2
    );
    ctx.fill();
    ctx.restore();
  }

  // Ëä±„ÅÆ‰∏≠ÂøÉ
  ctx.fillStyle = '#ffeef8';
  if (type === 2) ctx.fillStyle = '#f0f7ff';
  if (type === 3) ctx.fillStyle = '#fff8d0';
  ctx.beginPath();
  ctx.arc(0, centerYLocal, 4 * s, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}
// „É°„Ç§„É≥„ÅÆËä±ÔºàË™òÂ∞éÁî®„ÉªÂ∏∏„Å´1Ëº™Ôºâ
drawSingleFlower(flowerX, flowerBaseY, 1, 1, 0, true);

// Ëä±„ÅÆÊµ∑ÔºöËä±„ÇíÁîü„ÇÑ„Åô
if (flowerSeaActive) {
  flowerSpawnTicker += dt;
  if (flowerSpawnTicker > 180 && extraFlowers.length < flowerSeaCountGoal + 40) {
    flowerSpawnTicker = 0;
    const fx = w * (0.25 + Math.random() * 0.5);
    const fy = h * (0.74 + Math.random() * 0.12);
    const fType = 1 + Math.floor(Math.random() * 3);
    extraFlowers.push({
      x: fx,
      yBase: fy,
      type: fType,
      grow: 0,
      phase: Math.random() * Math.PI * 2
    });
  }
}

// ËøΩÂä†„ÅÆËä±„ÇíÊèèÁîªÔºàÂ∞ë„Åó„Åö„Å§ÊàêÈï∑Ôºâ
for (let f of extraFlowers) {
  if (f.grow < 1) {
    f.grow = Math.min(1, f.grow + dt / 2000);
  }
  drawSingleFlower(f.x, f.yBase, f.grow, f.type, f.phase, false);
}

// Ëä±„Åå‰∏ÄÂÆö‰ª•‰∏äÂ¢ó„Åà„Åü„Çâ„ÄåÈ°ò„ÅÑ„Çí„ÅäËä±„Å´Ëæº„ÇÅ„Çã„Äç„Éú„Çø„É≥Ë°®Á§∫
if (flowerSeaActive && !flowerWishAvailable && extraFlowers.length >= flowerSeaCountGoal) {
  flowerWishAvailable = true;
  if (wishButton) wishButton.classList.add('show');
}

// Ëä±ÂêπÈõ™„ÅÆËä±„Å≥„ÇâÔºà1Êûö„Åö„Å§Â∞ë„ÅóÈÅï„ÅÜÊ∏¶ÔºãÊñπÂêë„Å´Ôºâ
if (petalStormActive && petals.length > 0) {
  for (let i = petals.length - 1; i >= 0; i--) {
    const p = petals[i];
    p.life += dt;
    if (p.life > p.maxLife) {
      petals.splice(i, 1);
      continue;
    }
    const t = p.life / p.maxLife;
    const cx = w / 2;
    const cy = h * 0.3;
    const dx = p.x - cx;
    const dy = p.y - cy;
    const dist = Math.hypot(dx, dy) || 1;

    // ÂáèÂ∞ëÈáçÂäõÂΩ±ÂìçÔºåËÆ©Ëä±Áì£È£òÂæóÊõ¥‰πÖ
    const tangential = 0.00025 * dt * (p.tanDir || 1); // ÂáèÊÖ¢Ê∂°ÊóãÈÄüÂ∫¶
    p.vx += (-dy / dist) * tangential;
    p.vy += (dx / dist) * tangential;
    p.vy -= 0.0001 * dt; // ÂáèÂ∞ëÈáçÂäõÔºàÂéüÊù•ÊòØ0.00018Ôºâ

    p.x += p.vx * dt * 0.04; // ÂáèÊÖ¢Ê∞¥Âπ≥ÁßªÂä®
    p.y += p.vy * dt * 0.04;
    p.angle += p.angSpeed * dt;

    // ËÆ©Ëä±Áì£Êõ¥ÈÄèÊòéÔºåÊåÅÁª≠Êó∂Èó¥Êõ¥Èïø
    const alpha = 1 - Math.pow(t, 1.5); // ‰ΩøÁî®Êõ≤Á∫øËÆ©Ê∂àÂ§±Êõ¥Âπ≥Áºì
    const size = p.size * (0.8 + 0.4 * (1 - t));

    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);
    const grad = ctx.createLinearGradient(-size, -size, size, size);
    grad.addColorStop(0, 'rgba(255,255,255,' + (0.4 * alpha).toFixed(3) + ')');
    grad.addColorStop(0.5, p.color.replace('ALPHA', alpha.toFixed(3)));
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.6, size, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  if (petals.length === 0) {
    petalStormActive = false;
  }
}        ctx.restore();
      }
    }

    function spawnShootingStar() {
  if (starsSuspended) return;

  // ‚òÖ „Éë„Ç§„É≠„ÉÉ„Éà„Ç§„Éô„É≥„Éà‰∏≠„Å†„ÅëÂá∫ÁèæÁéáÔºÜ„Çµ„Ç§„Ç∫UP
  const baseProb = 0.006;
  const prob = ufoPilotMode ? baseProb * 15 : baseProb;
  const maxStars = ufoPilotMode ? 18 : 2;

  if (Math.random() < prob && shootingStars.length < maxStars) {
    // ÁîªÈù¢„ÅÆÂõõËæ∫„Åã„Çâ„É©„É≥„ÉÄ„É†„Å´Âá∫Áèæ
    const edge = ['left','right','top','bottom'][Math.floor(Math.random() * 4)];
    let startX, startY;

    if (edge === 'left') {
      startX = -80;
      startY = Math.random() * h;
    } else if (edge === 'right') {
      startX = w + 80;
      startY = Math.random() * h;
    } else if (edge === 'top') {
      startX = Math.random() * w;
      startY = -80;
    } else { // bottom
      startX = Math.random() * w;
      startY = h + 80;
    }

    // ÁîªÈù¢„ÅÆÂÜÖÂÅ¥„ÅÆ„Å©„Åì„Åã„Çí„Çø„Éº„Ç≤„ÉÉ„Éà„Å´„Åó„Å¶È£õ„Å∞„Åô
    const targetX = w * (0.2 + Math.random() * 0.6);
    const targetY = h * (0.15 + Math.random() * 0.5);

    const dx = targetX - startX;
    const dy = targetY - startY;
    const baseSpeed = 2 + Math.random() * 5;
    const len = Math.hypot(dx, dy) || 1;

    // ‚ë¢ UFOÊìçÁ∏¶„Ç§„Éô„É≥„Éà‰∏≠„ÅØ„Çπ„Éî„Éº„Éâ„ÇíÂçäÊ∏õ
    const speedMul = ufoPilotMode ? 0.5 : 1.0;
    const vx = (dx / len) * baseSpeed * speedMul;
    const vy = (dy / len) * baseSpeed * speedMul;

    const baseSize = 0.6 + Math.random() * 1.4;
    // ‚òÖ „Ç§„Éô„É≥„Éà‰∏≠„ÅØ 3„Äú20ÂÄç„É©„É≥„ÉÄ„É†
    const sizeFactor = ufoPilotMode ? baseSize * (3 + Math.random() * 7) : baseSize;

    shootingStars.push({
      x: startX,
      y: startY,
      vx,
      vy,
      life: 0,
      maxLife: 8000 + Math.random() * 1800,
      length: (90 + Math.random() * 50) * sizeFactor,
      hit: false,
      sizeFactor
    });
  }
}

    function updateShootingStars(dt) {
      for (let s of shootingStars) {
        s.x += s.vx;
        s.y += s.vy;
        s.life += dt;
      }
      for (let i = shootingStars.length - 1; i >= 0; i--) {
        const s = shootingStars[i];
        if (s.x < -200 || s.x > w + 200 || s.y > h + 200 || s.life > s.maxLife) {
          shootingStars.splice(i, 1);
        }
      }
    }

    function drawShootingStars() {
      const isBattle = ufoPilotMode;
      for (let s of shootingStars) {
        const lifeT = 1 - s.life / s.maxLife;
        const alpha = Math.max(0, Math.min(1, lifeT + 0.2));

        const len = s.length * (isBattle ? 1.2 : 1);
        const vlen = Math.hypot(s.vx, s.vy) || 1;
        const dx = -s.vx / vlen;
        const dy = -s.vy / vlen;
        const trailX = s.x + dx * len;
        const trailY = s.y + dy * len;

        ctx.globalAlpha = alpha;

        if (isBattle) {
          // ‚òÖ „Éê„Éà„É´‰∏≠ÔºöÁÅ´ÁêÉÔºãÂ°µ„Å£„ÅΩ„ÅÑÂ∞æ
          const grad = ctx.createLinearGradient(trailX, trailY, s.x, s.y);
          grad.addColorStop(0,   'rgba(40,10,0,0)');
          grad.addColorStop(0.2, 'rgba(255,180,80,0.5)');
          grad.addColorStop(0.5, 'rgba(255,230,160,0.9)');
          grad.addColorStop(1.0, 'rgba(255,255,255,1.0)');
          ctx.strokeStyle = grad;
          ctx.lineWidth = 2.3 * s.sizeFactor;
          ctx.beginPath();
          ctx.moveTo(trailX, trailY);
          ctx.lineTo(s.x, s.y);
          ctx.stroke();

          // Â°µ„ÉªÁÅ´Ëä±
          const steps = 4;
          for (let i = 1; i <= steps; i++) {
            const r = i / (steps + 1);
            const px = s.x + dx * len * r;
            const py = s.y + dy * len * r;
            const dustR = 2.5 * s.sizeFactor * (1 - r);
            ctx.fillStyle = 'rgba(255,210,140,' + (0.35 * (1 - r)).toFixed(3) + ')';
            ctx.beginPath();
            ctx.arc(px + (Math.random()-0.5)*4, py + (Math.random()-0.5)*4, dustR, 0, Math.PI * 2);
            ctx.fill();
          }

          // ÈöïÁü≥„Éò„ÉÉ„Éâ
          const headR = 4.5 * s.sizeFactor;
          const headGrad = ctx.createRadialGradient(
            s.x, s.y, 0,
            s.x, s.y, headR
          );
          headGrad.addColorStop(0, 'rgba(255,255,255,1)');
          headGrad.addColorStop(0.4, 'rgba(255,220,180,0.95)');
          headGrad.addColorStop(0.9, 'rgba(120,60,20,0.5)');
          headGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = headGrad;
          ctx.beginPath();
          ctx.arc(s.x, s.y, headR, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // ÈÄöÂ∏∏„É¢„Éº„ÉâÔºöÊó¢Â≠ò„ÅÆ„ÇÑ„Åï„Åó„ÅÑÊµÅ„ÇåÊòü
          const grad = ctx.createLinearGradient(trailX, trailY, s.x, s.y);
          grad.addColorStop(0, 'rgba(255,255,255,0)');
          grad.addColorStop(0.25, 'rgba(200,220,255,0.6)');
          grad.addColorStop(0.6, 'rgba(255,210,255,0.9)');
          grad.addColorStop(1, 'rgba(255,255,255,1)');
          ctx.strokeStyle = grad;
          ctx.lineWidth = 1.4 * s.sizeFactor;
          ctx.beginPath();
          ctx.moveTo(trailX, trailY);
          ctx.lineTo(s.x, s.y);
          ctx.stroke();

          const headGrad = ctx.createRadialGradient(
            s.x, s.y, 0,
            s.x, s.y, 4 * s.sizeFactor
          );
          headGrad.addColorStop(0, 'rgba(255,255,255,1)');
          headGrad.addColorStop(0.5, 'rgba(255,240,255,0.7)');
          headGrad.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = headGrad;
          ctx.beginPath();
          ctx.arc(s.x, s.y, 4 * s.sizeFactor, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.globalAlpha = 1;
      }
    }

      const flashOverlay = document.getElementById('flashOverlay');
    const scene = document.getElementById('scene');
    const hourglass = document.getElementById('hourglass');
    const glassEl = document.getElementById('glass');
    const hgOutline = document.getElementById('hgOutline');
    const sandTop = document.getElementById('sandTop');
    const sandBottom = document.getElementById('sandBottom');
    const sandStream = document.getElementById('sandStream');
    const sandParticles = document.getElementById('sandParticles');
    const sandFloor = document.getElementById('sandFloor');
    const cracks = document.getElementById('cracks');
    const magicButton = document.getElementById('magicButton');
    const hint = document.getElementById('hint');
    const fortuneEl = document.getElementById('fortune');
    const wishButton = document.getElementById('wishButton');

    let phase = 'flow';
    let fxMode = 'idle';
    let fxTime = 0;
    let shards = [];
    let lastTime = performance.now();
    let isAnimatingPixels = false;
    let crackStep = 0;
    let hitCount = 0;
    let pendingFortuneText = '';

    let glassBurstParticles = [];

    function randomSandGradient() {
      const c1 = palette[Math.floor(Math.random() * palette.length)];
      const c2 = palette[Math.floor(Math.random() * palette.length)];
      const c3 = palette[Math.floor(Math.random() * palette.length)];
      return `radial-gradient(circle at 10% 10%, ${c1} 0, ${c2} 40%, ${c3} 100%)`;
    }

    function randomSandGradientBottom() {
      const c1 = palette[Math.floor(Math.random() * palette.length)];
      const c2 = palette[Math.floor(Math.random() * palette.length)];
      const c3 = palette[Math.floor(Math.random() * palette.length)];
      return `radial-gradient(circle at 80% 0%, ${c1} 0, ${c2} 40%, ${c3} 100%)`;
    }

    function randomizeHourglass() {
  // ‚ë° ‰ΩçÁΩÆÔºöÁîªÈù¢„ÅÆÁ´Ø„Åã„Çâ 1/3 „ÇíÈô§„ÅÑ„Åü‰∏≠Â§Æ„Ç®„É™„Ç¢„ÅÆ„Åø„Å´„Åô„ÇãÔºàÁ¥Ñ 33„Äú67%Ôºâ
  const x = 33 + Math.random() * 34; // Ê®™ÊñπÂêëÔºö33%„Äú67%
  const y = 33 + Math.random() * 34; // Á∏¶ÊñπÂêëÔºö33%„Äú67%

  // ‚ë† „Çµ„Ç§„Ç∫Ôºö‰ªä„ÅÆÊúÄÂ§ßÂÄ§„ÅÆ 2/3 „Å´Á∏ÆÂ∞è
  const baseScale = 0.85 + Math.random() * 0.55;
  const scale = baseScale * (2 / 3);

  const grainSize = 0.7 + Math.random() * 0.8;

  hourglassNormX = x / 100;
  hourglassNormY = y / 100;

  document.documentElement.style.setProperty('--hg-x', `${x}%`);
  document.documentElement.style.setProperty('--hg-y', `${y}%`);
  document.documentElement.style.setProperty('--hg-scale', scale.toString());
  document.documentElement.style.setProperty('--grain-size', grainSize.toString());

  const topGrad = randomSandGradient();
  const bottomGrad = randomSandGradientBottom();
  sandTop.style.backgroundImage = topGrad;
  sandBottom.style.backgroundImage = bottomGrad;
  sandFloor.style.backgroundImage = bottomGrad;
}

    function resetFortune() {
  fortuneEl.textContent = '';
  fortuneEl.classList.remove('show');
  document.body.classList.remove('heaven');
  heavenMode = false;
  heavenReveal = 0;
  treeGrowth = 0;
  hgOutline.classList.remove('glow-strong');

  // ‚òÖ Ëä±„Åæ„Çè„Çä„Éª„Ç´„Éº„ÇΩ„É´„ÅÆ„É™„Çª„ÉÉ„Éà
  extraFlowers = [];
  flowerSeaActive = false;
  flowerWishAvailable = false;
  flowerSpawnTicker = 0;
  petals = [];
  petalStormActive = false;
  mainFlowerCenter = { x: 0, y: 0, r: 0 };
  mainFlowerHovered = false;
  document.body.style.cursor = '';

  if (wishButton) wishButton.classList.remove('show');
}

    function resetSandAnimations() {
      sandTop.classList.remove('run');
      sandBottom.classList.remove('run');
      sandStream.classList.remove('run');
      sandFloor.classList.remove('drain');
      void sandTop.offsetWidth;

      sandTop.style.opacity = '1';
      sandBottom.style.opacity = '0';
      sandStream.style.opacity = '1';
      sandParticles.style.opacity = '1';
      sandFloor.style.opacity = 0;
      sandFloor.style.transform = 'scaleY(0.7)';

      cracks.className = 'crack-layer';
      cracks.style.opacity = '';
      hgOutline.style.opacity = 1;
      hgOutline.classList.remove('shake');
      hgOutline.classList.remove('shatter');
      glassEl.style.opacity = 0.85;
      hourglass.style.opacity = 1;

      phase = 'flow';
      crackStep = 0;
      hitCount = 0;
      pendingFortuneText = '';
      glassBurstParticles = [];
    }

    function startSand() {
      phase = 'flow';
      sandTop.classList.add('run');
      sandBottom.classList.add('run');
      sandStream.classList.add('run');
      sandParticles.style.opacity = '1';
    }

    sandTop.addEventListener('animationend', () => {
      if (phase !== 'flow') return;
      onSandFinished();
    });

    function onSandFinished() {
      if (phase !== 'flow') return;
      phase = 'ended';
      sandStream.style.opacity = '0';
      sandParticles.style.opacity = '0';

      const count = Math.min(hitCount, 3);
      if (count === 0) {
        showFortune(FORTUNE_0);
        heavenMode = true;
        heavenReveal = 0;
        treeGrowth = 0;
        document.body.classList.add('heaven');
        hgOutline.classList.add('glow-strong');
        hourglass.style.opacity = 0;
        initHeavenCraters();
        initHeavenTree();
        setTimeout(enterMagicMode, 900);
      } else if (count === 1) {
        showFortune(FORTUNE_1);
        setTimeout(enterMagicMode, 900);
      } else if (count === 2) {
        showFortune(FORTUNE_2);
        setTimeout(enterMagicMode, 900);
      } else {
        pendingFortuneText = FORTUNE_3;
        runFullBreakSequence();
      }
    }

    function showFortune(text) {
  if (flashOverlay) {
    // „Åæ„ÅöËÉåÊôØ„Çí„Åµ„Çè„Å£„Å®Ëµ§„ÅèÂÖâ„Çâ„Åõ„Å¶„Åã„Çâ„ÄÅ„Åø„Åè„ÅòË°®Á§∫
    flashOverlay.classList.add('show');
    setTimeout(() => {
      flashOverlay.classList.remove('show');

      // ‚òÖ „Åì„Åì„Åã„ÇâÊúà„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„Éà„ÇíÈñãÂßãÔºà0 ‚Üí 1„Å´„É´„Éº„ÉóÂÅ¥„ÅßÈÄ≤„ÇÅ„ÇãÔºâ
      moonFade = 0;

      fortuneEl.textContent = text;
      fortuneEl.classList.add('show');
    }, 220);
  } else {
    // Âøµ„ÅÆ„Åü„ÇÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    moonFade = 0;
    fortuneEl.textContent = text;
    fortuneEl.classList.add('show');
  }
}

    function applyStarHitCrack() {
      if (phase !== 'flow') return;
      hitCount++;
      if (crackStep < 3) {
        crackStep++;
        cracks.className = 'crack-layer step' + crackStep;
        cracks.style.opacity = '';
      }
      hgOutline.classList.add('shake');
      setTimeout(() => { hgOutline.classList.remove('shake'); }, 400);

      // ‚òÖ 3Âõû‰ª•‰∏ä„Åß„Ç¨„É©„Çπ„ÅåÁÜ±„ÇíÂ∏Ø„Å≥„Å¶Ëµ§„ÅøÊºîÂá∫
      if (hitCount >= 3) {
        cracks.classList.add('hot');
      }
      // ‚òÖ 3ÂõûÁõÆ„ÅßÂº∑Âà∂ÁöÑ„Å´Á†ï„ÅëÊï£„ÇãÔºÜ3„Éí„ÉÉ„Éà‰ª•‰∏ä„ÅÆÈÅãÂã¢„Å´
      if (hitCount >= 3) {
        pendingFortuneText = FORTUNE_3;
        setTimeout(() => {
          if (phase === 'flow') {
            forceBreakNow();
          }
        }, 600);
      }
    }

    function forceBreakNow() {
      phase = 'ended';
      sandTop.classList.remove('run');
      sandBottom.classList.remove('run');
      sandStream.classList.remove('run');

      sandTop.style.opacity = '0';
      sandBottom.style.opacity = '0';
      sandStream.style.opacity = '0';
      sandParticles.style.opacity = '0';

      runFullBreakSequence();
    }

    function spawnGlassBurst() {
      glassBurstParticles = [];
      const rect = hourglass.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;

      for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        glassBurstParticles.push({
          x: cx + (Math.random() - 0.5) * rect.width * 0.2,
          y: cy + (Math.random() - 0.5) * rect.height * 0.2,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0,
          maxLife: 800 + Math.random() * 600,
          size: 3 + Math.random() * 4
        });
      }
    }

    function updateGlassBurst(dt) {
      for (let p of glassBurstParticles) {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.02;
        p.life += dt;
      }
      glassBurstParticles = glassBurstParticles.filter(p => p.life < p.maxLife);
    }

    function drawGlassBurst() {
      if (!glassBurstParticles.length) return;
      for (let p of glassBurstParticles) {
        const t = 1 - p.life / p.maxLife;
        ctx.globalAlpha = Math.max(0, t);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(p.x, p.y, p.size, p.size * 0.7);
      }
      ctx.globalAlpha = 1;
    }

    function runFullBreakSequence() {
      setTimeout(() => {
        sandFloor.style.opacity = 1;
        sandFloor.style.transform = 'scaleY(1)';
        hgOutline.classList.add('shatter');
        spawnGlassBurst();
        glassEl.style.opacity = 0;
        cracks.style.opacity = 0;
      }, 200);

      hgOutline.addEventListener('animationend', () => {
        hgOutline.style.opacity = 0;
      }, { once: true });

      setTimeout(() => {
        if (pendingFortuneText) {
          showFortune(pendingFortuneText);
        }
      }, 1400);

      setTimeout(() => {
        startSandFall(() => {
          sandFloor.style.opacity = 0;
          setTimeout(enterMagicMode, 900);
        });
      }, 2100);
    }

    function startSandFall(onComplete) {
      const rect = hourglass.getBoundingClientRect();
      const baseY = rect.bottom - rect.height * 0.02;
      const centerX = rect.left + rect.width / 2;
      const offsetX = rect.width * 0.18;
      const grad = sandFloor.style.backgroundImage || randomSandGradientBottom();

      const left = document.createElement('div');
      left.className = 'sand-fall';
      left.style.left = (centerX - offsetX) + 'px';
      left.style.top = baseY + 'px';
      left.style.backgroundImage = grad;

      const right = document.createElement('div');
      right.className = 'sand-fall';
      right.style.left = (centerX + offsetX - 4) + 'px';
      right.style.top = baseY + 'px';
      right.style.backgroundImage = grad;

      document.body.appendChild(left);
      document.body.appendChild(right);

      sandFloor.classList.add('drain');

      requestAnimationFrame(() => {
        left.classList.add('animate');
        right.classList.add('animate');
      });

      setTimeout(() => {
        left.remove();
        right.remove();
        sandFloor.classList.remove('drain');
        if (onComplete) onComplete();
      }, 3800);
    }

    function enterMagicMode() {
      magicButton.classList.add('show');
      hint.classList.add('show');
    }

    function leaveMagicMode() {
      magicButton.classList.remove('show');
      hint.classList.remove('show');
    }

   function startPetalStorm() {
  if (!heavenMode) return;
  petalStormActive = true;
  petals = [];
  if (wishButton) wishButton.classList.remove('show');

  const sources = [];

  // ‰ªé‰∏ªËä±ÂíåÊâÄÊúâËä±‰∏äÊñπ‰∏ÄÁÇπÂºÄÂßã
  if (mainFlowerCenter.r > 0) {
    sources.push({ 
      x: mainFlowerCenter.x, 
      y: mainFlowerCenter.y - 40 // Ëµ∑Âßã‰ΩçÁΩÆÊõ¥È´ò
    });
  }
  
  // Ê∑ªÂä†ÂÖ∂‰ªñËä±
  for (let f of extraFlowers) {
    sources.push({ 
      x: f.x, 
      y: f.yBase - 60 // Ëµ∑Âßã‰ΩçÁΩÆÊõ¥È´ò
    });
  }
  
  if (!sources.length) return;

  // Â¢ûÂä†Ëä±Áì£Êï∞Èáè
  const baseCount = Math.max(120, sources.length * 50);
  const colorChoices = [
    'rgba(255,180,220,ALPHA)',
    'rgba(220,210,255,ALPHA)',
    'rgba(255,235,180,ALPHA)',
    'rgba(200,240,255,ALPHA)'  // Â¢ûÂä†‰∏ÄÁßçÈ¢úËâ≤
  ];

  for (let i = 0; i < baseCount; i++) {
    const src = sources[Math.floor(Math.random() * sources.length)];
    const angle = Math.random() * Math.PI * 2;
    const speed = 0.05 + Math.random() * 0.12; // Á®çÂæÆÂáèÊÖ¢ÈÄüÂ∫¶
    petals.push({
      x: src.x + (Math.random() - 0.5) * 40, // Êõ¥ÂàÜÊï£
      y: src.y + (Math.random() - 0.5) * 20,
      vx: Math.cos(angle) * speed,
      vy: -0.15 - Math.random() * 0.1, // Êõ¥ÂæÄ‰∏äÈ£ò
      angle: Math.random() * Math.PI * 2,
      angSpeed: (Math.random() - 0.5) * 0.2, // ÂáèÊÖ¢ÊóãËΩ¨
      life: 0,
      maxLife: 36000 + Math.random() * 4000, // Â¢ûÂä†ÁîüÂëΩÂë®Êúü
      size: 3 + Math.random() * 4,
      color: colorChoices[Math.floor(Math.random() * colorChoices.length)],
      tanDir: (Math.random() < 0.5 ? -1 : 1) * (0.5 + Math.random() * 0.4)
    });
  }
}

    // ‚òÖ „ÄåÈ°ò„ÅÑ„Çí„ÅäËä±„Å´Ëæº„ÇÅ„Çã„Äç„Éú„Çø„É≥ÔºöÊäº„Åó„Å£„Å±„Å™„Åó„ÅßÁô∫Âãï
    let wishFilling = false;
    let wishStartTime = 0;
    const WISH_HOLD_MS = 1000;

    function setWishFill(v) {
      const c = Math.max(0, Math.min(1, v));
      document.documentElement.style.setProperty('--wish-fill', c);
    }

    if (wishButton) {
      const startWish = (e) => {
        // „Çº„É≠„Éí„ÉÉ„Éà„ÅÆÂ§©ÂõΩ„Ç∑„Éº„É≥„Åß„ÄÅËä±„ÅÆÊµ∑„ÅåÂá∫„Å¶„ÅÑ„ÇãÊôÇ„Å†„ÅëÊúâÂäπ
        if (!(heavenMode && hitCount === 0 && flowerSeaActive && flowerWishAvailable && !petalStormActive)) {
          return;
        }
        wishFilling = true;
        wishStartTime = performance.now();
        wishButton.classList.add('sparkling');
        setWishFill(0);
      };

      const stopWish = () => {
        if (!wishFilling) return;
        wishFilling = false;
        wishButton.classList.remove('sparkling');
        setWishFill(0);
      };

      wishButton.addEventListener('mousedown', startWish);
      wishButton.addEventListener('mouseup', stopWish);
      wishButton.addEventListener('mouseleave', stopWish);

      // „Çπ„Éû„ÉõÂØæÂøúÔºàÂøÖË¶Å„Å™„Åë„Çå„Å∞Ââä„Å£„Å¶„ÇÇOKÔºâ
      wishButton.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startWish(e);
      }, { passive: false });
      wishButton.addEventListener('touchend', stopWish);
      wishButton.addEventListener('touchcancel', stopWish);
    }

    function createShards() {
      shards = [];
      const cols = 70;
      const rows = 70;
      const cellW = w / cols;
      const cellH = h / rows;
      const cx = w / 2;
      const cy = h / 2;

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const px = x * cellW + cellW / 2;
          const py = y * cellH + cellH / 2;
          const speed = 2 + Math.random() * 3;
          const angle = Math.atan2(py - cy, px - cx);
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const color = palette[Math.floor(Math.random() * palette.length)];
          shards.push({
            x: px,
            y: py,
            vx,
            vy,
            size: Math.random() * 4 + 3,
            alpha: 1,
            floatPhase: Math.random() * Math.PI * 2
          });
        }
      }
    }

    let swirlCenterX = w/2;
    let swirlCenterY = h/2;

    function updateShards(dt) {
  if (fxMode === 'explode') {
    fxTime += dt;
    for (let s of shards) {
      s.x += s.vx;
      s.y += s.vy;
      s.vx *= 0.99;
      s.vy *= 0.99;
    }
    if (fxTime > 900) {
      fxMode = 'float';
      fxTime = 0;
    }
  } else if (fxMode === 'float') {
    fxTime += dt;
    for (let s of shards) {
      s.floatPhase += 0.002 * dt;
      s.x += Math.cos(s.floatPhase) * 0.06 * (s.size);
      s.y += Math.sin(s.floatPhase) * 0.06 * (s.size);
      s.y += Math.sin(s.floatPhase * 0.7) * 0.01 * dt;
    }
    if (fxTime > 5000) {
      // ‚òÖ „Åì„Åì„Åã„ÇâÊ∏¶„Éï„Çß„Éº„Ç∫„Å∏
      fxMode = 'swirl';
      fxTime = 0;
      swirlCenterX = w * (0.2 + Math.random() * 0.6);
      swirlCenterY = h * (0.1 + Math.random() * 0.25);

      // Ê∏¶„ÅÆ‰∏≠ÂøÉ Ôºù Êñ∞„Åó„ÅÑÊúà„ÅÆ‰ΩçÁΩÆ
      moonNormX = swirlCenterX / w;
      moonNormY = swirlCenterY / h;
      moonRebirth = 0;
    }
  } else if (fxMode === 'swirl') {
    fxTime += dt;
    const duration = 7000;
    const tNorm = Math.min(1, fxTime / duration);
    const cx = swirlCenterX;
    const cy = swirlCenterY;

    // Â∞ë„Åó„Å†„Åë„Éû„Ç§„É´„Éâ„ÇÅ„ÅÆÂõûËª¢ÔºÜÂèéÊùü
    const spinBase = 0.015 + 0.25 * tNorm;
    const pullBase = -0.02 - 0.45 * tNorm;

    const step = (dt / 16) || 1;
    for (let s of shards) {
      const dx = s.x - cx;
      const dy = s.y - cy;
      let r = Math.hypot(dx, dy) + 0.01;
      let ang = Math.atan2(dy, dx);

      r += pullBase * step;
      ang += spinBase * step;

      s.x = cx + Math.cos(ang) * r;
      s.y = cy + Math.sin(ang) * r;

      const centerDist = Math.hypot(s.x - cx, s.y - cy);
      if (centerDist < 40) {
        s.alpha -= 0.0025 * step;
      } else {
        s.alpha -= 0.0006 * step;
      }
    }
    shards = shards.filter(s => s.alpha > 0);

    // ‚òÖ Ê∏¶„ÅÆÁµÇÁõ§ 30% „ÅßÊúà„Åå 0 ‚Üí 1 „ÅßÁîü„Åæ„Çå„Å¶„Åè„Çã
    if (tNorm < 0.7) {
      moonRebirth = 0;
    } else {
      const r = (tNorm - 0.7) / 0.3;
      moonRebirth = Math.min(1, Math.max(0, r));
    }

    if (fxTime > duration) {
      fxMode = 'idle';
      fxTime = 0;
      shards = [];
      isAnimatingPixels = false;
      scene.classList.remove('hide');
      scene.style.pointerEvents = 'auto';
      starsSuspended = false;

      // ÊúÄÁµÇÁöÑ„Å´Êñ∞„Åó„ÅÑÊúà„ÅåÂÆåÂÖ®„Å´Áèæ„Çå„ÅüÁä∂ÊÖã„Å´
      moonRebirth = 1;
      moonFade = 0;

      randomizeHourglass();
      resetFortune();
      resetSandAnimations();
      startSand();
    }
  }
}

    function drawShards() {
      if (!shards.length) return;
      const prevComp = ctx.globalCompositeOperation;
      ctx.globalCompositeOperation = 'lighter';
      for (let s of shards) {
        ctx.globalAlpha = Math.max(0, s.alpha);
        ctx.fillStyle = s.color;
        ctx.fillRect(
          Math.round(s.x - s.size / 2),
          Math.round(s.y - s.size / 2),
          s.size,
          s.size
        );
      }
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = prevComp;
    }

    function triggerPixelShatter() {
      if (isAnimatingPixels) return;
      isAnimatingPixels = true;
      fortuneEl.classList.remove('show');
      leaveMagicMode();

      // ‚òÖ Êúà„Éï„Çß„Éº„Éâ„Çí„Çº„É≠„Åã„ÇâÈñãÂßã
      moonFade = 0;
      moonRebirth = 0;

      scene.classList.add('hide');
      scene.style.pointerEvents = 'none';
      starsSuspended = true;
      shootingStars.length = 0;

      setTimeout(() => {
        createShards();
        fxMode = 'explode';
        fxTime = 0;
        phase = 'pixel';
      }, 300);
    }

    let magicFilling = false;
    let magicStartTime = 0;
    const MAGIC_HOLD_MS = 1000;

    function setMagicFill(v) {
      const c = Math.max(0, Math.min(1, v));
      document.documentElement.style.setProperty('--magic-fill', c);
    }

    magicButton.addEventListener('mousedown', () => {
      if (phase !== 'ended' || fxMode !== 'idle') return;
      magicFilling = true;
      magicStartTime = performance.now();
    });

    magicButton.addEventListener('mouseup', () => {
      if (!magicFilling) return;
      if (performance.now() - magicStartTime < MAGIC_HOLD_MS) {
        magicFilling = false;
        setMagicFill(0);
      }
    });

    magicButton.addEventListener('mouseleave', () => {
      if (!magicFilling) return;
      magicFilling = false;
      setMagicFill(0);
    });

// „Çπ„Éû„ÉõÂØæÂøúÔºöÊäº„Åó„Å£„Å±„Å™„ÅóÔºàtouchÔºâ
magicButton.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (phase !== 'ended' || fxMode !== 'idle') return;
  magicFilling = true;
  magicStartTime = performance.now();
}, { passive: false });

magicButton.addEventListener('touchend', () => {
  if (!magicFilling) return;
  if (performance.now() - magicStartTime < MAGIC_HOLD_MS) {
    magicFilling = false;
    setMagicFill(0);
  }
});

magicButton.addEventListener('touchcancel', () => {
  if (!magicFilling) return;
  magicFilling = false;
  setMagicFill(0);
});

    let draggingShards = false;

function repelShardsAt(clientX, clientY) {
  if (!draggingShards || fxMode === 'idle') return;
  const x = clientX;
  const y = clientY;
  const radius = 140;

  for (let s of shards) {
    const dx = s.x - x;
    const dy = s.y - y;
    const dist = Math.hypot(dx, dy);
    if (dist < radius) {
      const force = (radius - dist) / radius * 0.45;
      s.x += (dx / (dist || 1)) * force * 18;
      s.y += (dy / (dist || 1)) * force * 18;
    }
  }
}

// mouse
canvas.addEventListener('mousedown', () => {
  if (fxMode === 'idle') return;
  draggingShards = true;
});
window.addEventListener('mouseup', () => {
  draggingShards = false;
});
canvas.addEventListener('mousemove', (e) => {
  repelShardsAt(e.clientX, e.clientY);
});

// touch
canvas.addEventListener('touchstart', (e) => {
  if (fxMode === 'idle') return;
  draggingShards = true;
  const t = e.touches[0];
  if (t) repelShardsAt(t.clientX, t.clientY);
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  const t = e.touches[0];
  if (t) repelShardsAt(t.clientX, t.clientY);
  e.preventDefault();
}, { passive: false });

window.addEventListener('touchend', () => { draggingShards = false; }, { passive: true });
window.addEventListener('touchcancel', () => { draggingShards = false; }, { passive: true });



   function deflectShootingStars() {
  if (shootingStars.length === 0) return;
  for (let s of shootingStars) {
    const speed = Math.hypot(s.vx, s.vy) || 1;
    const dirSign = s.vx >= 0 ? 1 : -1;
    const baseDeg = 30 + Math.random() * 90;
    const rad = baseDeg * Math.PI / 180;
    const upward = Math.random() < 0.5;
    const vy = Math.sin(rad) * speed * (upward ? -1 : 1);
    const vx = Math.cos(rad) * speed * dirSign;
    s.vx = vx;
    s.vy = vy;
  }
}

window.addEventListener('dblclick', () => {
  deflectShootingStars();
});

// „Çπ„Éû„ÉõÔºöËÉåÊôØ(canvas)„ÅÆ„ÉÄ„Éñ„É´„Çø„ÉÉ„Éó„ÅßÂêåÁ≠âÂãï‰Ωú
let lastTapTs = 0;
window.addEventListener('touchend', (e) => {
  if (e.target !== canvas) return; // „Éú„Çø„É≥Á≠â„ÅÆ„ÉÄ„Éñ„É´„Çø„ÉÉ„ÉóË™§ÁàÜ„ÇíÈÅø„Åë„Çã
  const now = performance.now();
  if (now - lastTapTs < 320) {
    e.preventDefault();
    deflectShootingStars();
    lastTapTs = 0;
  } else {
    lastTapTs = now;
  }
}, { passive: false });

    // ‚òÖ Ëä±„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®Ëä±„ÅÆÊµ∑„É¢„Éº„ÉâÈñãÂßã
   function tryStartFlowerSeaAt(clientX, clientY) {
  if (!heavenMode) return;
  if (hitCount !== 0) return;          // „Çº„É≠„Éí„ÉÉ„ÉàÊôÇ„Å†„Åë
  if (!mainFlowerCenter.r) return;
  if (petalStormActive) return;        // Ëä±ÂêπÈõ™‰∏≠„ÅØÁÑ°Ë¶ñ

  const x = clientX;
  const y = clientY;
  const dx = x - mainFlowerCenter.x;
  const dy = y - mainFlowerCenter.y;
  if (dx * dx + dy * dy <= mainFlowerCenter.r * mainFlowerCenter.r) {
    flowerSeaActive = true;
  }
}

window.addEventListener('click', (e) => {
  tryStartFlowerSeaAt(e.clientX, e.clientY);
});

// „Çø„ÉÉ„ÉÅ„Åß„ÇÇÁ¢∫ÂÆü„Å´ÈñãÂßã
window.addEventListener('touchend', (e) => {
  const t = e.changedTouches && e.changedTouches[0];
  if (!t) return;
  tryStartFlowerSeaAt(t.clientX, t.clientY);
}, { passive: true });

// ‚òÖ ‰∏ÄËº™„ÅÆËä±„ÅÆ„Éõ„Éê„Éº„Åß„Ç´„Éº„ÇΩ„É´„ÇíÈ¢®„Ç¢„Ç§„Ç≥„É≥„Å´
window.addEventListener('mousemove', (e) => {
  if (!(heavenMode && hitCount === 0 && !petalStormActive && mainFlowerCenter.r > 0)) {
    if (mainFlowerHovered) {
      mainFlowerHovered = false;
      document.body.style.cursor = '';
    }
    return;
  }

  const dx = e.clientX - mainFlowerCenter.x;
  const dy = e.clientY - mainFlowerCenter.y;
  const inside = dx * dx + dy * dy <= mainFlowerCenter.r * mainFlowerCenter.r;

  if (inside && !mainFlowerHovered) {
    mainFlowerHovered = true;
    document.body.style.cursor = WIND_CURSOR;
  } else if (!inside && mainFlowerHovered) {
    mainFlowerHovered = false;
    document.body.style.cursor = '';
  }
});

    function checkStarHitHourglass() {
      if (shootingStars.length === 0) return;
      if (phase !== 'flow') return;
      if (fxMode !== 'idle') return;

      const rect = hourglass.getBoundingClientRect();
      const hgLeft = rect.left;
      const hgRight = rect.right;
      const hgTop = rect.top;
      const hgBottom = rect.bottom;

      for (let s of shootingStars) {
        if (s.hit) continue;
        if (s.x > hgLeft && s.x < hgRight && s.y > hgTop && s.y < hgBottom) {
          s.hit = true;
          applyStarHitCrack();
        }
      }
    }

    function loop(now) {
      const dt = now - lastTime;
      lastTime = now;
            globalTime += dt;

      if (magicFilling) {
        const elapsed = now - magicStartTime;
        const ratio = elapsed / MAGIC_HOLD_MS;
        setMagicFill(ratio);
        if (ratio >= 1) {
          magicFilling = false;
          triggerPixelShatter();
          setMagicFill(0);
        }
      }

        if (wishFilling) {
        const elapsedW = now - wishStartTime;
        const ratioW = elapsedW / WISH_HOLD_MS;
        setWishFill(ratioW);
        if (ratioW >= 1) {
          wishFilling = false;
          setWishFill(1);
          wishButton.classList.remove('sparkling');
          startPetalStorm();
        }
      }

      if (heavenMode) {
        heavenReveal = Math.min(1, heavenReveal + dt / 1500);
        treeGrowth = Math.min(1, treeGrowth/100 + dt / 4000);
      } else {
        heavenReveal = 0;
        treeGrowth = 0;
      }

     // ‚òÖ „Åø„Åè„ÅòË°®Á§∫‰∏≠„ÅØ„ÄÅÊúà„Çí„ÇÜ„Å£„Åè„Çä„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„Éà
  if (
    !heavenMode &&
    fxMode === 'idle' &&
    phase !== 'pixel' &&
    fortuneEl.classList.contains('show')
  ) {
    // Á¥Ñ1Áßí„Äú1.2Áßí„Åè„Çâ„ÅÑ„ÅßÊ∂à„Åà„Çã„Ç§„É°„Éº„Ç∏
    moonFade = Math.min(1, moonFade + dt / 1000);
  }

  updateMoonDots(dt);
  drawBackground(dt);

      maybeSpawnUfo();
      updateUfo(dt);
      drawUfo();

      spawnShootingStar();
      updateShootingStars(dt);
      drawShootingStars();

      if (glassBurstParticles.length) {
        updateGlassBurst(dt);
        drawGlassBurst();
      }

      if (fxMode !== 'idle') {
        updateShards(dt);
        drawShards();
      }

      checkStarHitHourglass();
      requestAnimationFrame(loop);
    }

    initMoonDots();
    randomizeMoon();
    randomizeHourglass();
    resetFortune();
    resetSandAnimations();
    startSand();
    requestAnimationFrame(loop);
  </script>

  <!-- „Åì„Åì„Åã„ÇâËøΩÂä†„Çπ„ÇØ„É™„Éó„ÉàÔºàUFO„Éë„Ç§„É≠„ÉÉ„Éà„Ç§„Éô„É≥„ÉàÔºâ -->
  <script>
  (function(){
    const canvas = document.getElementById('fx');
    const hourglass = document.getElementById('hourglass');
    if (!canvas || !hourglass) return;

    const hgUi = document.createElement('div');
    hgUi.className = 'hg-ui';
    hgUi.innerHTML = `
      <div id="hgTimer" class="hg-timer"></div>
      <div class="hg-hp-shell"><div id="hgHpBar" class="hg-hp-bar"></div></div>
    `;
    document.body.appendChild(hgUi);
    const hgTimerEl = document.getElementById('hgTimer');
    const hgHpBarEl = document.getElementById('hgHpBar');

    const ufoHud = document.createElement('div');
    ufoHud.id = 'ufoHud';
    ufoHud.className = 'ufo-hud';
    ufoHud.innerHTML = `
      <div class="ufo-hud-title">UFO PILOT MODE</div>
      <div class="ufo-hud-keys">
        <span>W / A / S / D : ÁßªÂãïÔºàÊÖ£ÊÄß„ÅÇ„ÇäÔºâ</span>
        <span>Space : „Éê„É™„Ç¢„ÅßÊµÅ„ÇåÊòü„Çí„Åù„Çâ„Åô</span>
        <span>B : „Éì„Éº„É†„Åß‰∏ÄÁï™Ëøë„ÅÑÊµÅ„ÇåÊòü„ÇíÁ≤âÁ†ï</span>
      </div>
      <div class="ufo-hud-shield" id="ufoHudShield"></div>
    `;
    document.body.appendChild(ufoHud);
    const ufoHudShieldEl = document.getElementById('ufoHudShield');

    const ufoMsg = document.createElement('div');
    ufoMsg.id = 'ufoMessage';
    ufoMsg.className = 'ufo-message';
    document.body.appendChild(ufoMsg);

    function positionHgUi(){
      const rect = hourglass.getBoundingClientRect();
      hgUi.style.left = (rect.left + rect.width/2) + 'px';
      hgUi.style.top  = (rect.top - rect.height*0.08) + 'px';
    }
    window.addEventListener('resize', positionHgUi);
    positionHgUi();

    ufoPilotMode = false;   // ‚òÖ„Ç∞„É≠„Éº„Éê„É´„Çí„É™„Çª„ÉÉ„Éà„Åô„Çã„Å†„Åë„Å´Â§âÊõ¥
    let pilotTimer = 0;
    const UFO_BARRIER_MAX = 3;
    let ufoBarrierUses = 0;
    let ufoBarrierActive = false;
    let ufoBarrierTimer = 0;
    const UFO_BARRIER_DURATION = 3000;
    const UFO_BARRIER_RADIUS = 120;
    let ufoVelX = 0, ufoVelY = 0;

    // ‚òÖ ËøΩÂä†Ôºö„Éê„É™„Ç¢Ôºè„Éì„Éº„É†ÊèèÁîªÁî®„ÅÆÂÜÖÈÉ®Áä∂ÊÖã
    let honeycombPhase = 0;

    let beamActive = false;
    let beamTimer = 0;
    let beamFrom = { x: 0, y: 0 };
    let beamTo   = { x: 0, y: 0 };
    const BEAM_DURATION = 260;   // „Éì„Éº„É†„ÅåÂ±ä„Åè„Åæ„Åß„ÅÆÊôÇÈñì(ms)
    let beamExplosions = [];     // ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàÁî®

    let keys = {};
    window.addEventListener('keydown', function(e){
      keys[e.code] = true;
      if (ufoPilotMode && ['KeyW','KeyA','KeyS','KeyD','Space','KeyB'].includes(e.code)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', function(e){
      keys[e.code] = false;
    });

    let moonPressing = false;
    let moonPressElapsed = 0;
    let moonCountdownActive = false;
    let moonCountdown = 0;
    let moonCountdownMs = 0;
    let moonEventInProgress = false;
    let moonSpinBoost = 0;
    let moonAuraPhase = 0;   // „Ç´„É©„Éï„É´„Ç™„Éº„É©ÂõûËª¢Áî®

    function resetMoonCharge(){
      moonPressing = false;
      moonPressElapsed = 0;
      moonCountdownActive = false;
      moonCountdown = 0;
      moonCountdownMs = 0;
      moonEventInProgress = false;
      moonSpinBoost = 0;
    }

    function updateTimerDisplay(){
      if (!hgTimerEl) return;
      if (!ufoPilotMode) {
        hgTimerEl.textContent = '';
        return;
      }
      const sec = Math.ceil(pilotTimer / 1000);
      const s = sec < 10 ? '0' + sec : '' + sec;
      hgTimerEl.textContent = s + ':00';
    }

    function updateHpBar(){
      if (!hgHpBarEl) return;
      if (!ufoPilotMode) {
        hgHpBarEl.style.width = '0%';
        return;
      }
      // ‚òÖ ÊúÄÂ§ß3„Éí„ÉÉ„Éà„Åæ„ÅßËÄê„Åà„Çã
      const maxHits = 3;
      const hpFrac = Math.max(0, maxHits - hitCount) / maxHits;
      hgHpBarEl.style.width = (hpFrac * 100) + '%';
    }

    function updateHudShield(){
      if (!ufoHudShieldEl) return;
      const ratio = ufoPilotMode ? (ufoBarrierUses / UFO_BARRIER_MAX) : 0;
      ufoHudShieldEl.style.setProperty('--shield-ratio', ratio.toString());
      ufoHudShieldEl.style.opacity = ratio > 0 ? '1' : '0.3';
    }

    function showUfoMessage(text){
      if (!ufoMsg) return;
      ufoMsg.textContent = text;
      ufoMsg.classList.remove('fade');
      ufoMsg.classList.add('show');
      setTimeout(() => {
        ufoMsg.classList.add('fade');
        setTimeout(() => {
          ufoMsg.classList.remove('show');
          ufoMsg.classList.remove('fade');
        }, 450);
      }, 2600);
    }

    function startUfoPilotMode(){
      if (!ufo) return;
      ufoPilotMode = true;
      pilotTimer = 30000;
      ufoBarrierUses = UFO_BARRIER_MAX;
      ufoBarrierActive = false;
      ufoBarrierTimer = 0;
      ufoVelX = 0;
      ufoVelY = 0;

      resetSandAnimations();
      resetFortune();
      startSand();

      positionHgUi();
      hgUi.classList.add('show');
      ufoHud.classList.add('show');
      updateTimerDisplay();
      updateHpBar();
      updateHudShield();

      moonSpinBoost = 90;
      if (bgmInitialized) {
        setBgmMode('battle');
      }

   
      // ‚òÖ ËøΩÂä†Ôºö„Çø„ÉÉ„ÉÅ„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºË°®Á§∫Ôºà„É¢„Éê„Ç§„É´„ÅÆ„ÅøÔºâ
      if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        const touchController = document.getElementById('touchController');
        if (touchController) {
          touchController.classList.add('show');
        }
      }
    }

    function endUfoPilotMode(){
      if (!ufoPilotMode) return;
      ufoPilotMode = false;
      pilotTimer = 0;
      hgUi.classList.remove('show');
      ufoHud.classList.remove('show');
      ufoBarrierActive = false;
      ufoBarrierTimer = 0;
      ufoBarrierUses = 0;
      moonSpinBoost = 0;
      resetMoonCharge();
      updateHudShield();
      if (bgmInitialized) {
        setBgmMode('normal');
      }
      
      // ‚òÖ ËøΩÂä†Ôºö„Çø„ÉÉ„ÉÅ„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÈùûË°®Á§∫
      const touchController = document.getElementById('touchController');
      if (touchController) {
        touchController.classList.remove('show');
      }
    }

    const _updateMoonDotsBase = updateMoonDots;

    function tryStartUfoPilotEvent(){
      moonCountdownActive = false;
      moonEventInProgress = false;
      if (ufo && !heavenMode && fxMode === 'idle' && phase === 'flow') {
        showUfoMessage('UFO„ÅÆ„Éë„Ç§„É≠„ÉÉ„Éà„Å®„Åó„Å¶„ÄÅ60Áßí„ÅÆÈñìÁ†ÇÊôÇË®à„ÇíÂÆà„Å£„Å¶„ÅÇ„Åí„Å¶ÔºÅ');
        startUfoPilotMode();
      } else {
        showUfoMessage('‰Ωï„ÇÇËµ∑„Åç„Å™„Åã„Å£„Åü...‰Ωï„ÅãÊù°‰ª∂„Åå„Åù„Çç„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÇÇÔºü');
        resetMoonCharge();
      }
    }

    updateMoonDots = function(dt){
      const isCharging = moonPressing || moonCountdownActive;
      if (isCharging || ufoPilotMode) {
        moonAuraPhase += dt * 0.002;
        if (moonAuraPhase > 1000000) moonAuraPhase = 0;
      }

      if (!heavenMode && fxMode === 'idle' && phase === 'flow' && !ufoPilotMode) {
        if (moonPressing) {
          moonPressElapsed += dt;
          
              moonSpinBoost += dt * 0.025;
          if (!moonCountdownActive && moonPressElapsed >= 1000) {
            moonCountdownActive = true;
            moonCountdown = 3;
            moonCountdownMs = 800;
          }
        } else {
        if (!ufoPilotMode) {
          // ÈÄöÂ∏∏ÊôÇ„ÅØÂæê„ÄÖ„Å´Ê∏õË°∞
          moonSpinBoost -= dt * 0.001;
          if (moonSpinBoost < 0) moonSpinBoost = 0;
        } else {
          // „Éë„Ç§„É≠„ÉÉ„Éà‰∏≠„ÅØÊúÄÈ´ò„Çπ„Éî„Éº„Éâ„ÇíÁ∂≠ÊåÅ
          moonSpinBoost += dt * 0.5;
          if (moonSpinBoost < 9) moonSpinBoost = 9;
        }
      }
        if (moonCountdownActive) {
          moonCountdownMs -= dt;
          if (moonCountdownMs <= 0) {
            moonCountdown--;
            if (moonCountdown <= 0) {
              moonCountdownActive = false;
              tryStartUfoPilotEvent();
            } else {
              moonCountdownMs += 1000;
            }
          }
        }
      } else {
        moonSpinBoost += dt * 0.0025;
        if (moonSpinBoost < 0) moonSpinBoost = 0;
      }

      const factor = 1 + moonSpinBoost;
      _updateMoonDotsBase(dt * factor);
    };

    const _drawBackgroundBase = drawBackground;
    drawBackground = function(dt){
      _drawBackgroundBase(dt);

      if (ufoPilotMode && phase === 'flow') {
        pilotTimer -= dt;
        if (pilotTimer < 0) pilotTimer = 0;
        updateTimerDisplay();
        updateHpBar();
        if (ufoBarrierActive) {
          ufoBarrierTimer -= dt;
          if (ufoBarrierTimer <= 0) {
            ufoBarrierActive = false;
            updateHudShield();
          }
        }
      }

      if (!heavenMode) {
        const { x: moonX, y: moonY } = getMoonPosition();
        const moonR = Math.min(w, h) * 0.09;
        ctx.save();

        const isCharging = moonPressing || moonCountdownActive;
        if (moonEventInProgress || moonCountdownActive || ufoPilotMode) {
          const auraR = moonR * 1.45;
          let g;
          if (isCharging || ufoPilotMode) {
            // Èï∑Êäº„Åó‰∏≠Ôºö„Ç´„É©„Éï„É´„Å´ÂõûËª¢„Åô„Çã„Ç™„Éº„É©
            const baseHue = (moonAuraPhase * 0.08) % 360;
            const hue2 = (baseHue + 70) % 360;
            const hue3 = (baseHue + 160) % 360;
            g = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, auraR);
            g.addColorStop(0.0, `hsla(${baseHue}, 100%, 85%, 0.98)`);
            g.addColorStop(0.4, `hsla(${hue2}, 90%, 70%, 0.7)`);
            g.addColorStop(1.0, `hsla(${hue3}, 80%, 55%, 0.0)`);
          } else {
            // ÈÄöÂ∏∏„ÅÆÊüî„Çâ„Åã„ÅÑ„Ç™„Éº„É©
            g = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, auraR);
            g.addColorStop(0, 'rgba(255,255,255,0.95)');
            g.addColorStop(0.4, 'rgba(200,230,255,0.5)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
          }
          ctx.globalAlpha = 0.8;
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(moonX, moonY, auraR, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        if (moonCountdownActive) {
          ctx.fillStyle = 'rgba(255,255,255,0.95)';
          ctx.font = 'bold 22px system-ui, -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(moonCountdown), moonX - moonR * 1.6, moonY);
        }

         if (ufoPilotMode && ufoBarrierActive && ufo) {
          // ‚òÖ „Éè„ÉÅ„ÅÆÂ∑£„Å£„ÅΩ„ÅÑÂÖ≠ËßíÂΩ¢„Éê„É™„Ç¢
          honeycombPhase += dt;
          ctx.save();
          ctx.strokeStyle = 'rgba(160,230,255,0.70)';
          ctx.lineWidth = 1.6;

          const baseR = UFO_BARRIER_RADIUS * 0.5;
          const rings = 2;
          const cells = 32;

          for (let ring = 0; ring < rings; ring++) {
            const ringR = baseR + ring * 18;
            for (let i = 0; i < cells; i++) {
              const ang = (Math.PI * 2 / cells) * i + honeycombPhase * 0.0015 * (ring ? 1.3 : 1.0);
              const cxh = ufo.x + Math.cos(ang) * ringR;
              const cyh = ufo.y + Math.sin(ang) * ringR;
              const r = 7 + ring * 3;

              ctx.beginPath();
              for (let k = 0; k < 6; k++) {
                const a = Math.PI / 3 * k;
                const px = cxh + Math.cos(a) * r;
                const py = cyh + Math.sin(a) * r;
                if (k === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
              }
              ctx.closePath();
              ctx.stroke();
            }
          }
          ctx.restore();
        }

        // ‚òÖ „Éì„Éº„É†„ÅÆÊèèÁîªÔºàUFO„Éë„Ç§„É≠„ÉÉ„Éà„É¢„Éº„Éâ‰∏≠ÔºöÁßªÂãïÔºãÁàÜÁô∫Ôºâ
        if (beamActive && ufoPilotMode && ufo) {
          beamTimer -= dt;
          const t = Math.max(0, Math.min(1, 1 - beamTimer / BEAM_DURATION));

          ctx.save();
          const bx = beamFrom.x;
          const by = beamFrom.y;
          const tx = beamTo.x;
          const ty = beamTo.y;
          const dx = tx - bx;
          const dy = ty - by;
          const ex = bx + dx * t;
          const ey = by + dy * t;

          const g2 = ctx.createLinearGradient(bx, by, ex, ey);
          g2.addColorStop(0.0, 'rgba(255,255,255,0.0)');
          g2.addColorStop(0.3, 'rgba(255,255,255,0.95)');
          g2.addColorStop(1.0, 'rgba(160,230,255,0.0)');

          ctx.strokeStyle = g2;
          ctx.lineWidth = 6;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(bx, by);
          ctx.lineTo(ex, ey);
          ctx.stroke();
          ctx.restore();

          // „Éì„Éº„É†Âà∞ÈÅî ‚Üí ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàÁîüÊàêÔºãÊµÅ„ÇåÊòüÂâäÈô§
          if (beamTimer <= 0) {
            beamActive = false;

            const exX = beamTo.x;
            const exY = beamTo.y;
            const expCount = 18;
            for (let i = 0; i < expCount; i++) {
              const ang = (Math.PI * 2 * i) / expCount + Math.random() * 0.5;
              const speed = 0.12 + Math.random() * 0.22;
              beamExplosions.push({
                x: exX,
                y: exY,
                vx: Math.cos(ang) * speed,
                vy: Math.sin(ang) * speed,
                life: 0,
                maxLife: 450 + Math.random() * 250
              });
            }

            if (shootingStars.length && beamTo) {
              let closestIndex = -1;
              let bestDist = Infinity;
              for (let i = 0; i < shootingStars.length; i++) {
                const s = shootingStars[i];
                const dx2 = s.x - exX;
                const dy2 = s.y - exY;
                const d2 = dx2*dx2 + dy2*dy2;
                if (d2 < bestDist) {
                  bestDist = d2;
                  closestIndex = i;
                }
              }
              if (closestIndex >= 0) {
                shootingStars.splice(closestIndex, 1);
              }
            }
          }
        }

        // ‚òÖ „Éì„Éº„É†ÁàÜÁô∫„ÅÆÊèèÁîª
        if (beamExplosions.length) {
          for (let i = beamExplosions.length - 1; i >= 0; i--) {
            const e = beamExplosions[i];
            e.life += dt;
            const t = e.life / e.maxLife;
            if (t >= 1) {
              beamExplosions.splice(i, 1);
              continue;
            }
            const alpha = 1 - t;
            const radius = 10 + 80 * t;

            ctx.save();
            const gex = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, radius);
            gex.addColorStop(0, 'rgba(255,255,255,' + alpha.toFixed(3) + ')');
            gex.addColorStop(0.4, 'rgba(255,210,180,' + (alpha*0.9).toFixed(3) + ')');
            gex.addColorStop(1, 'rgba(80,30,10,0)');
            ctx.fillStyle = gex;
            ctx.beginPath();
            ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        ctx.restore();
      }

      if (heavenMode && ufoPilotMode) {
        endUfoPilotMode();
      }
    };

    const _maybeSpawnUfoBase = maybeSpawnUfo;
    maybeSpawnUfo = function(){
      if (ufoPilotMode) return;
      _maybeSpawnUfoBase();
    };

    const _updateUfoBase = updateUfo;
    updateUfo = function(dt){
      if (!ufoPilotMode) {
        _updateUfoBase(dt);
        return;
      }
      if (!ufo) return;
      ufo.t += dt;
      ufo.depthPhase += dt * 0.0015;

       // ‚òÖ „Ç§„Éô„É≥„Éà‰∏≠„ÅØ„Çπ„Éî„Éº„Éâ„ÉªÂä†ÈÄüÂ∫¶„ÉªÊÖ£ÊÄß„Çí„Å†„ÅÑ„Åü„ÅÑ2.5ÂÄç
      const speedFactor = 2.5;
      const acc = 0.009 * speedFactor * dt;
      if (keys['KeyW']) ufoVelY -= acc;
      if (keys['KeyS']) ufoVelY += acc;
      if (keys['KeyA']) ufoVelX -= acc;
      if (keys['KeyD']) ufoVelX += acc;

      // Ê∏õË°∞„Çí„Åï„Çâ„Å´Âº±„ÇÅ„Å¶„ÄÅ„Åã„Å™„ÇäÊªë„ÇãÊåôÂãï„Å´
      ufoVelX *= 0.99;
      ufoVelY *= 0.99;

      // ÂÆüÈöõ„ÅÆÁßªÂãï„ÇÇ2.5ÂÄç
      ufo.x += ufoVelX * speedFactor;
      ufo.y += ufoVelY * speedFactor;

      const margin = 80;
      if (ufo.x < -margin) ufo.x = -margin;
      if (ufo.x > w + margin) ufo.x = w + margin;
      if (ufo.y < -margin) ufo.y = -margin;
      if (ufo.y > h + margin) ufo.y = h + margin;

      const depth = 0.5 + 0.5 * Math.sin(ufo.depthPhase);
      ufo.currScale = ufo.scale * (0.7 + 0.6 * depth);
    };

    const _updateShootingStarsBase = updateShootingStars;
    updateShootingStars = function(dt){
      _updateShootingStarsBase(dt);

      // „Éê„É™„Ç¢„Åß„Åù„Çâ„ÅôÂá¶ÁêÜÔºàÊó¢Â≠òÔºâ
      if (ufoPilotMode && ufoBarrierActive && ufo) {
        for (let s of shootingStars) {
          const dx = s.x - ufo.x;
          const dy = s.y - ufo.y;
          const dist = Math.hypot(dx, dy);
          if (dist < UFO_BARRIER_RADIUS) {
            const speed = Math.hypot(s.vx, s.vy) || 1;
            const angle = Math.atan2(s.vy, s.vx);
            const deflect = (Math.random() - 0.5) * (Math.PI / 1.5);
            const na = angle + deflect;
            s.vx = Math.cos(na) * speed;
            s.vy = Math.sin(na) * speed;
          }
        }
      }

      // ‚òÖ „Éê„É™„Ç¢„Åå„Å™„ÅÑ„Å®„Åç„Å´ UFO Êú¨‰Ωì„Å´ÂëΩ‰∏≠„Åó„Åü„Çâ‰∏ÄÊíÉÁàÜÁô∫
      if (ufoPilotMode && ufo && !ufoBarrierActive) {
        const UFO_HIT_RADIUS = 40;  // ÂΩì„Åü„ÇäÂà§ÂÆö„ÅÆÂ§ß„Åç„Åï

        for (let i = shootingStars.length - 1; i >= 0; i--) {
          const s = shootingStars[i];
          const dx = s.x - ufo.x;
          const dy = s.y - ufo.y;
          const dist = Math.hypot(dx, dy);

          if (dist < UFO_HIT_RADIUS) {
            // ÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„ÉàÔºà„Éì„Éº„É†ÁàÜÁô∫„Å®Âêå„ÅòÈÖçÂàó„ÇíÊµÅÁî®Ôºâ
            const expCount = 24;
            for (let k = 0; k < expCount; k++) {
              const ang = (Math.PI * 2 * k) / expCount;
              const speed = 0.18 + Math.random() * 0.24;
              beamExplosions.push({
                x: ufo.x,
                y: ufo.y,
                vx: Math.cos(ang) * speed,
                vy: Math.sin(ang) * speed,
                life: 0,
                maxLife: 600 + Math.random() * 400
              });
            }

            shootingStars.splice(i, 1);
            showUfoMessage('UFO„ÅåÊµÅ„ÇåÊòü„Å´ÊíÉÂ¢ú„Åï„Çå„Åü‚Ä¶');
            ufo = null;
            endUfoPilotMode();
// 3Âõû„Éí„ÉÉ„ÉàÁõ∏ÂΩì„ÅÆÂ§ßÁ†¥„Å®„Åó„Å¶Êâ±„ÅÜ
            hitCount = 3;
            pendingFortuneText = FORTUNE_3;
            forceBreakNow();

            break;
          }
        }
      }
    };

    const _checkStarHitHourglassBase = checkStarHitHourglass;
    checkStarHitHourglass = function(){
      _checkStarHitHourglassBase();
      if (ufoPilotMode && phase === 'flow') {
        updateHpBar();
      }
    };

    const _onSandFinishedBase = onSandFinished;
    onSandFinished = function(){
      _onSandFinishedBase();
      endUfoPilotMode();
    };

    const _forceBreakNowBase = forceBreakNow;
    forceBreakNow = function(){
      _forceBreakNowBase();
      endUfoPilotMode();
    };

    const _triggerPixelShatterBase = triggerPixelShatter;
    triggerPixelShatter = function(){
      endUfoPilotMode();
      _triggerPixelShatterBase();
    };

    function fireBeam(){
      if (!ufoPilotMode || !ufo) return;
      if (!shootingStars.length) return;

      let best = null;
      let bestDist = Infinity;
      for (let s of shootingStars) {
        const dx = s.x - ufo.x;
        const dy = s.y - ufo.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestDist) {
          bestDist = d2;
          best = s;
        }
      }
      if (!best) return;

      // ‚òÖ „Éì„Éº„É†ÊºîÂá∫Áî®„ÅÆÊÉÖÂ†±„Çí„Çª„ÉÉ„ÉàÔºàÂâäÈô§„ÅØÂæå„ÅßÔºâ
      beamFrom = { x: ufo.x, y: ufo.y };
      beamTo   = { x: best.x, y: best.y };
      beamTimer = BEAM_DURATION;
      beamActive = true;
    }

    window.addEventListener('keydown', function(e){
      if (!ufoPilotMode) return;
      if (e.code === 'Space') {
        if (!ufoBarrierActive && ufoBarrierUses > 0) {
          ufoBarrierActive = true;
          ufoBarrierTimer = UFO_BARRIER_DURATION;
          ufoBarrierUses--;
          updateHudShield();
        }
      } else if (e.code === 'KeyB') {
        fireBeam();
      }
    });

    function isOnMoon(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const moonX = w * moonNormX;
      const moonY = h * moonNormY;
      const moonR = Math.min(w, h) * 0.09;
      const dx = x - moonX;
      const dy = y - moonY;
      return dx*dx + dy*dy <= moonR*moonR;
    }

    window.addEventListener('mousedown', function(e){
      if (e.button !== 0) return;
      if (fxMode !== 'idle' || heavenMode || ufoPilotMode || phase !== 'flow') return;
      if (!isOnMoon(e.clientX, e.clientY)) return;
      moonPressing = true;
      moonPressElapsed = 0;
      moonEventInProgress = true;
    });

    window.addEventListener('mouseup', function(){
      if (moonPressing && !moonCountdownActive) {
        resetMoonCharge();
      }
      moonPressing = false;
    });

    // „Çπ„Éû„ÉõÔºöÊúà„ÅÆÈï∑Êäº„Åó„ÅßÂêå„Åò„ÉÅ„É£„Éº„Ç∏ÊåôÂãï
window.addEventListener('touchstart', function(e){
  if (fxMode !== 'idle' || heavenMode || ufoPilotMode || phase !== 'flow') return;
  const t = e.touches && e.touches[0];
  if (!t) return;
  if (!isOnMoon(t.clientX, t.clientY)) return;
  e.preventDefault();
  moonPressing = true;
  moonPressElapsed = 0;
  moonEventInProgress = true;
}, { passive: false });

window.addEventListener('touchend', function(){
  if (moonPressing && !moonCountdownActive) {
    resetMoonCharge();
  }
  moonPressing = false;
}, { passive: true });

window.addEventListener('touchcancel', function(){
  if (moonPressing && !moonCountdownActive) {
    resetMoonCharge();
  }
  moonPressing = false;
}, { passive: true });


 // ===== „Åì„Åì„Å´„Çø„ÉÉ„ÉÅ„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„Ç§„Éô„É≥„ÉàÂá¶ÁêÜ„ÇíËøΩÂä† =====
    // „Çø„ÉÉ„ÉÅ„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„Ç§„Éô„É≥„ÉàÂá¶ÁêÜ
    (function setupTouchController() {
      const touchController = document.getElementById('touchController');
      if (!touchController) return;
      
      const dpadButtons = touchController.querySelectorAll('.dpad-btn');
      const actionButtons = touchController.querySelectorAll('.action-btn');
      
      let activeTouchKeys = new Set();
      
      // „Çø„ÉÉ„ÉÅÈñãÂßã
      function handleTouchStart(e) {
        e.preventDefault();
        const button = e.target.closest('.dpad-btn, .action-btn');
        if (!button || !ufoPilotMode) return;
        
        const key = button.getAttribute('data-key');
        if (key) {
          keys[key] = true;
          activeTouchKeys.add(key);
          button.classList.add('active');
          
          // „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà„Çí„Ç∑„Éü„É•„É¨„Éº„ÉàÔºàÊó¢Â≠ò„ÅÆÂá¶ÁêÜ„ÇíÂãï„Åã„Åô„Åü„ÇÅÔºâ
          const keyboardEvent = new KeyboardEvent('keydown', { code: key });
          window.dispatchEvent(keyboardEvent);
        }
      }
      
      // „Çø„ÉÉ„ÉÅÁµÇ‰∫Ü
      function handleTouchEnd(e) {
        e.preventDefault();
        const button = e.target.closest('.dpad-btn, .action-btn');
        if (!button) return;
        
        const key = button.getAttribute('data-key');
        if (key && activeTouchKeys.has(key)) {
          keys[key] = false;
          activeTouchKeys.delete(key);
          button.classList.remove('active');
          
          // „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
          const keyboardEvent = new KeyboardEvent('keyup', { code: key });
          window.dispatchEvent(keyboardEvent);
        }
      }
      
      // „Çø„ÉÉ„ÉÅ„Åå„Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÂ§ñ„Å´Âá∫„ÅüÂ†¥Âêà
      function handleTouchCancel(e) {
        if (!ufoPilotMode) return;
        
        // ÂÖ®„Å¶„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Ç≠„Éº„Çí„ÇØ„É™„Ç¢
        activeTouchKeys.forEach(key => {
          keys[key] = false;
          const keyboardEvent = new KeyboardEvent('keyup', { code: key });
          window.dispatchEvent(keyboardEvent);
        });
        
        activeTouchKeys.clear();
        
        // ÂÖ®„Å¶„ÅÆ„Éú„Çø„É≥„ÅÆactiveÁä∂ÊÖã„ÇíËß£Èô§
        dpadButtons.forEach(btn => btn.classList.remove('active'));
        actionButtons.forEach(btn => btn.classList.remove('active'));
      }
      
      // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÁôªÈå≤
      dpadButtons.forEach(btn => {
        btn.addEventListener('touchstart', handleTouchStart, { passive: false });
        btn.addEventListener('touchend', handleTouchEnd, { passive: false });
        btn.addEventListener('touchcancel', handleTouchEnd, { passive: false });
      });
      
      actionButtons.forEach(btn => {
        btn.addEventListener('touchstart', handleTouchStart, { passive: false });
        btn.addEventListener('touchend', handleTouchEnd, { passive: false });
        btn.addEventListener('touchcancel', handleTouchEnd, { passive: false });
      });
      
      // ÁîªÈù¢„Çø„ÉÉ„ÉÅ„ÅåÂ§ñ„Çå„ÅüÂ†¥Âêà„ÅÆÂá¶ÁêÜ
      document.addEventListener('touchcancel', handleTouchCancel, { passive: true });
      document.addEventListener('touchend', function(e) {
        if (e.target.closest('.touch-controller')) return;
        // „Ç≥„É≥„Éà„É≠„Éº„É©„ÉºÂ§ñ„Åß„Çø„ÉÉ„ÉÅÁµÇ‰∫Ü„Åó„ÅüÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
      }, { passive: true });
      
      // „Éû„Ç¶„ÇπÊìç‰Ωú„ÇÇ„Çµ„Éù„Éº„ÉàÔºàPC„Åß„Çø„ÉÉ„ÉÅ„Éë„Éç„É´„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
      dpadButtons.forEach(btn => {
        btn.addEventListener('mousedown', function(e) {
          if (!ufoPilotMode) return;
          e.preventDefault();
          const key = btn.getAttribute('data-key');
          if (key) {
            keys[key] = true;
            btn.classList.add('active');
            const keyboardEvent = new KeyboardEvent('keydown', { code: key });
            window.dispatchEvent(keyboardEvent);
          }
        });
        
        btn.addEventListener('mouseup', function(e) {
          e.preventDefault();
          const key = btn.getAttribute('data-key');
          if (key) {
            keys[key] = false;
            btn.classList.remove('active');
            const keyboardEvent = new KeyboardEvent('keyup', { code: key });
            window.dispatchEvent(keyboardEvent);
          }
        });
        
        btn.addEventListener('mouseleave', function(e) {
          if (btn.classList.contains('active')) {
            const key = btn.getAttribute('data-key');
            if (key) {
              keys[key] = false;
              btn.classList.remove('active');
              const keyboardEvent = new KeyboardEvent('keyup', { code: key });
              window.dispatchEvent(keyboardEvent);
            }
          }
        });
      });
      
      actionButtons.forEach(btn => {
        btn.addEventListener('mousedown', function(e) {
          if (!ufoPilotMode) return;
          e.preventDefault();
          const key = btn.getAttribute('data-key');
          if (key) {
            keys[key] = true;
            btn.classList.add('active');
            const keyboardEvent = new KeyboardEvent('keydown', { code: key });
            window.dispatchEvent(keyboardEvent);
          }
        });
        
        btn.addEventListener('mouseup', function(e) {
          e.preventDefault();
          const key = btn.getAttribute('data-key');
          if (key) {
            keys[key] = false;
            btn.classList.remove('active');
            const keyboardEvent = new KeyboardEvent('keyup', { code: key });
            window.dispatchEvent(keyboardEvent);
          }
        });
        
        btn.addEventListener('mouseleave', function(e) {
          if (btn.classList.contains('active')) {
            const key = btn.getAttribute('data-key');
            if (key) {
              keys[key] = false;
              btn.classList.remove('active');
              const keyboardEvent = new KeyboardEvent('keyup', { code: key });
              window.dispatchEvent(keyboardEvent);
            }
          }
        });
      });
    })();
    // ===== „Çø„ÉÉ„ÉÅ„Ç≥„É≥„Éà„É≠„Éº„É©„Éº„Ç§„Éô„É≥„ÉàÂá¶ÁêÜ „Åì„Åì„Åæ„Åß ====

  })();
  </script>
  <!-- ËøΩÂä†„Çπ„ÇØ„É™„Éó„Éà„Åì„Åì„Åæ„Åß -->

</body>
</html>
